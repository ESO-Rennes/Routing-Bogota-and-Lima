---
title: "Distancias Bogotá EODH 2023"
author: "Hugo Thomas"
date: "`r Sys.Date()`"
output: 
  html_document: 
    toc: yes
    code_folding: "hide"
---

```{r setup, include=FALSE}
    knitr::opts_chunk$set(warning = FALSE, message = FALSE, verbose = FALSE) 
    knitr::opts_chunk$set(dev = "svg",
                          dpi = 300,
                          echo = TRUE,
                          cache = TRUE)
```


# Trabajo preliminar

## Paquetes R

```{r Paquetes}
library(sp)
library(sf)
library(sfnetworks)
library(dodgr)
library(tidygraph)
library(data.table)
library(dplyr)
library(purrr)
library(TSP)
library(openxlsx)
library(spatstat)
library(raster)
library(stars)
library(terra)
library(ggplot2)
library(ggspatial)
library(knitr)
library(tidyr)
library(stringr)
library(RColorBrewer)
library(foreach)
library(doFuture)
library(mapsf)
library(showtext)
library(gridGraphics)
library(grid)
```

## Cargando los datos del cuestionario

```{r Data}
ZAT <- st_read(dsn = "231031_ZAT_2023", layer = "231031_ZAT_2023") %>% st_transform(4326) %>% filter(UTAM != "N/A")
ZATCentroids <- st_centroid(ZAT)
 
setwd("C:/Users/hugot/Documents/Rennes 2/Calcul distance SIG/Reprise perso/RMD Bogota")

UTAM <- st_read(dsn = "Data", layer = "EMU2019_area")
EF <- read.xlsx("Data/facteurs d'émissions.xlsx")
limites_bogota <- st_read(dsn = "Data", layer = "Localidad_Municipio_2017") %>% # Municipalities boundaries
  st_transform(4326) 

setwd("C:/Users/hugot/Documents/Uniandes/EODH2023/EODH 2023 oficial/Publicacion1804/EODH/02_Base datos procesada/XLSX")

Hogares <- read.xlsx("a. Modulo hogares.xlsx")
Personas <- read.xlsx("c. Modulo personas.xlsx")
viajes <- read.xlsx("d. Modulo viajes.xlsx")
#Etapas <- read.xlsx("e. Modulo etapas.xlsx")
#Vehiculos <- read.xlsx("b. Modulo vehiculos.xlsx")

setwd("C:/Users/hugot/Documents/Uniandes/EODH2023")

#Esta base es necesaria para tener la ubicación del hogar
Hogares_loc <- read.xlsx(xlsxFile = "ANEXO 2_BASE DE DATOS EODH CON FACTORES DE EXPANSIÓN.xlsx", sheet = "hogar A-C-X-CF")
#Estas base son necesarias para deducir si el lugar de origen y destino de cada viaje es hogar u otro
Personas_viaj_no_procesada <- read.xlsx(xlsxFile = "ANEXO 2_BASE DE DATOS EODH CON FACTORES DE EXPANSIÓN.xlsx", sheet = "modulo D-E")
Viajes_no_procesada <- read.xlsx(xlsxFile = "ANEXO 2_BASE DE DATOS EODH CON FACTORES DE EXPANSIÓN.xlsx", sheet = "viajes")
```

## Cargando los datos SHP

```{r Cargando datos SHP}
setwd("C:/Users/hugot/Documents/Rennes 2/Calcul distance SIG/Reprise perso/RMD Bogota")

Routes <- st_read(dsn = "Data", layer = "Reseau_routier") 
Routes <- st_cast(Routes, "LINESTRING") %>% st_transform(4326)
Transmi <- st_read(dsn = "Data", layer = "Transmilenio") %>% st_transform(4326)  
Transmi_stops <- st_read(dsn = "Data", layer = "estaciones-de-transmilenio") %>% st_transform(4326)
```

## Procesos preliminares

Se definen las categorías de modos que se usarán dentro del modelo de distancias

```{r categorias de modos}
modos <- data.frame(modo_principal_desagrupado = unique(viajes$modo_principal_desagrupado),
                    modo_principal_typo = c("Auto", "Bicicleta", "A pie", "A pie", "Intermunicipal", "TransMilenio", "Transporte publico individual", "SITP Zonal", "Moto", "Alimentador", "Moto", "Auto", "Transporte publico individual", "Auto", "Transporte publico individual", "Bicitaxi", "SITP Zonal", "Transporte Escolar", "Auto", "Transporte informal", "Otro", "Otro", "Otro", "Transporte informal", "Auto", "Otro", "Bicicleta", "Cable", "Otro", "Patineta", "Bicicleta", "Otro", "Otro"),
                    modo_principal_comparado = c("Auto", "Bicicleta", "A pie", "A pie", "Transporte publico", "Transporte publico", "Taxi / Carro por aplicación", "Transporte publico", "Moto", "Transporte publico", "Moto", "Auto", "Taxi / Carro por aplicación", "Auto", "Taxi / Carro por aplicación", "Transporte informal", "Transporte publico", "Transporte Escolar", "Auto", "Transporte informal", "Otro", "Otro", "Otro", "Transporte informal", "Auto", "Otro", "Bicicleta", "Transporte publico", "Otro", "Otro", "Bicicleta", "Otro", "Otro"),
                    modo_principal_LATS = c("Private car", "Bike", "Walking", "Walking", "Regular bus", "BRT", "Taxi", "Regular bus", "Moto", "Regular bus", "Moto", "Private car", "Taxi", "Private car", "Taxi", "Paratransit", "BRT", "School bus", "Private car", "Paratransit", "Other", "Other", "Other", "Paratransit", "Private car", "Other", "Bike", "BRT", "Other", "Other", "Bike", "Other", "Other"))

viajes <- viajes %>% left_join(modos, by = "modo_principal_desagrupado")
```

Excluimos los viajes entrando o saliendo del area conformado por el Distrito de Bogotá y los 20 municipios que fueron encuestados. Para ello, se conservan solo los viajes que empiezan y terminan en las ZAT para los cuales tenemos un archivo SHP con su geometría y a los cuales les corresponde una UTAM. A la fecha, se usa el archivo con las 1,215 ZAT de 2023, y se reduce el número de viajes en la base de 100,174 a 96,054 (-4%).

```{r filtro sobre viajes salientes o entrantes}
#UTAM_presentes <- data.frame(UTAM = unique(c(Hogares$cod_utam_hg, viajes$utam_des, viajes$utam_ori))) %>% filter(UTAM != "No aplica")
#ZAT_presentes <- data.frame(ZAT = unique(c(Hogares$zat_hg, viajes$zat_des, viajes$zat_ori)))
#write.xlsx(UTAM_presentes, "UTAM_EODH_2023.xlsx")
#write.xlsx(ZAT_presentes, "ZAT_EODH_2023.xlsx")

viajes <- viajes[viajes$zat_des %in% ZAT$ZAT & viajes$zat_ori %in% ZAT$ZAT,]
```

Necesitamos recuperar las coordenadas de los hogares desde la versión de trabajo de la encuesta.

```{r localización de los hogares}
Hogares <- Hogares %>% 
  left_join(Hogares_loc[,c("i7a-Latitude", "i7a-Longitude", "KEY")], by = c("key_hg" = "KEY")) %>%
  st_as_sf(coords = c("i7a-Longitude", "i7a-Latitude"), crs = 4326) 

Hogares_loc <- Hogares_loc[,c("i7a-Latitude", "i7a-Longitude", "cod_dane","KEY")] %>%
  st_as_sf(coords = c("i7a-Longitude", "i7a-Latitude"), crs = 4326) 

#st_write(Hogares_loc, "Hogares_loc_mza.shp")

#Definición de la ventana
zoom_level <- 9.5
lon_span <- 360 / 2^zoom_level
lat_span <- 360 / 2^zoom_level

zoom_to_Bogota <- c(-74.12, 4.72)  # Bogota
lon_bounds_Bogota <- c(zoom_to_Bogota[1] - lon_span / 2, zoom_to_Bogota[1] + lon_span / 2)
lat_bounds_Bogota <- c(zoom_to_Bogota[2] - lat_span / 2, zoom_to_Bogota[2] + lat_span / 2)

UTAM <- UTAM %>% st_transform(4326)

ggplot()+
  theme_bw()+
  geom_sf(data = UTAM, fill = "white")+
  geom_sf(data = Hogares_loc, col = "red", size = 0.5)+
  labs(title = "Ubicación de los hogares de la muestra", 
       subtitle = "Bogotá DC + 20 municipios", 
       caption = "Autor: Hugo Thomas - Université Rennes 2 / Universidad de los Andes \nFuente: Encuesta Origen-Destino de Hogares, Secretaría Distrital de Movilidad, 2023", 
       col = "UPZ") +
  coord_sf(xlim = lon_bounds_Bogota, ylim = lat_bounds_Bogota, datum = NA)+
  labs(x = "", y = "") +
  theme(legend.position = "right",
        legend.text = element_text(size=10),
        legend.title = element_text(size=15),
        plot.title = element_text(size=15),
        plot.caption = element_text(size = 7, face = "italic", hjust = 0, vjust = 12),
        legend.text.align = 1)+
  annotation_scale(location = "br", height = unit(0.12, "cm"),text_cex = 0.8) +
  annotation_north_arrow(location = "tl", which_north = "true", height = unit(1, "cm"), width = unit(0.8, "cm"))
```

Finalmente necesitamos identificar para cada viaje si sus puntos de origen y destino son el hogar de la persona u otro. Para hacerlo, necesitamos buscar en la versión de trabajo de la base de viajes la variable que contiene esta información para el lugar de destino únicamente (lastimosamente no la hay para el lugar de origen). Luego, para el lugar de origen del primer viaje del día, buscamos esta información en la version de trabajo de la base de viajes. 
Este procedimiento busca aumentar la precisión de los viajes que comienzan o terminan en el hogar

```{r viajes que comienzan o terminan en casa}
#Lugar destino
viajes <- viajes %>% left_join(Viajes_no_procesada[,c("d24","KEY")], by = c("key_viaje" = "KEY"))
colnames(viajes)[colnames(viajes) == "d24"] <- "lugar_destino"
viajes$lugar_destino[viajes$lugar_destino == 1] <- "Hogar"
viajes$lugar_destino[viajes$lugar_destino == 2] <- "Otro lugar"

#Lugar origen (funciona solo para el primer viaje del día)
Personas_viaj_no_procesada$KEY_2 <- gsub(pattern = "person_d_e", replacement = "B/person_b", Personas_viaj_no_procesada$KEY)
Personas <- Personas %>% left_join(Personas_viaj_no_procesada[,c("d7", "KEY_2")], by = c("key_persona" = "KEY_2"))
colnames(Personas)[colnames(Personas) == "d7"] <- "lugar_ini_dia"
Personas$lugar_ini_dia[Personas$lugar_ini_dia == 1] <- "Hogar"
viajes <- viajes %>% left_join(Personas[,c("cod_per", "lugar_ini_dia")], by = c("cod_pers" = "cod_per"))
viajes$lugar_origen <- "Otro lugar"
viajes$lugar_origen[viajes$lugar_ini_dia == "Hogar" & viajes$orden_vj == 1] <- "Hogar"

#Control (no debe haber viajes Hogar --> Hogar)
viajes$test_origen_destino[viajes$lugar_origen == "Hogar" & viajes$lugar_destino == "Hogar"] <- "HOGAR_HOGAR"
viajes$test_origen_destino[viajes$lugar_origen == "Hogar" & viajes$lugar_destino == "Otro lugar"] <- "HOGAR_Otro"
viajes$test_origen_destino[viajes$lugar_origen == "Otro lugar" & viajes$lugar_destino == "Hogar"] <- "Otro_HOGAR"
viajes$test_origen_destino[viajes$lugar_origen == "Otro lugar" & viajes$lugar_destino == "Otro lugar"] <- "Otro_Otro"
print(table(viajes$test_origen_destino))

#Encontramos un (1) viaje "Hogar --> Hogar". Quitamos todos los viajes de la persona que lo realiza del registro de viajes
excl <- viajes$cod_pers[viajes$test_origen_destino == "HOGAR_HOGAR"]
viajes <- viajes[!(viajes$cod_pers %in% excl),]
```


# Inicialización de las redes

## Red vial

```{r ini red vial dodgr}
# Ponderación de los segmentos y restricción al principal componente conexo
net_mot <- weight_streetnet(Routes, wt_profile = "motorcar", type_col = "type")
net_mot <- net_mot[net_mot$component == 1,]
net_cycl <- weight_streetnet(Routes, wt_profile = "bicycle", type_col = "type")
net_cycl <- net_cycl[net_cycl$component == 1,]
net_walk <- weight_streetnet(Routes, wt_profile = "foot", type_col = "type")
net_walk <- net_walk[net_walk$component == 1,]
```

## Transmilenio

```{r ini red transmi sf_networks}
Transmi <- st_cast(Transmi, "LINESTRING")
Transmi_stops <- Transmi_stops %>% st_transform(4326)

# Inicialización
net_transmi = as_sfnetwork(Transmi, directed = FALSE) %>%
  st_transform(4326) %>%
  activate("edges") %>%
  mutate(weight = edge_length())

# Subdivisión de ejes
net_transmi = convert(net_transmi, to_spatial_subdivision)

# Inclusión (blend) de las estaciones a la red
net_transmi = st_network_blend(net_transmi, Transmi_stops)

# Cálculo de la nueva longitud de cada eje
net_transmi <- net_transmi %>% activate("edges") %>% mutate(weight = edge_length())
```

# Cálculo de las distancias

## Matrices de distancias

Se calcula la longitud de cada viaje de acuerdo a los siguiente:

* Se le asigna un modo principal
* Se escoge una red de acuerdo al modo principal (ver tabla adjunta) para la asignación del viaje origen-destino.
* Se calculan las rutas desde y hasta los centroides de las ZAT de origen y destino (si éste es cualquiera (caso general), o desde/hasta el hogar cuando aplica.

Modo principal  | Red empleada                        | Paquete empleado
----------------|-------------------------------------|------------------
Transmilenio    | Transmilenio                        | _sfnetworks_
SITP Zonal      | SITP                                | _r5r_
Alimentador     | SITP                                | _r5r_
A pie           | Red vial (ponderación peatón)       | _dodgr_
Bicicleta       | Red vial (ponderación ciclista)     | _dodgr_
Cualquier otro  | Red vial (ponderación automovilista)| _dodgr_


```{r Calculo de matrices de distancia, eval = TRUE}
print(Sys.time())

#5 min

#LINEA RECTA (para sustituir NA)
# 1 --> 2 (Hogar --> ZAT) 
mat_straight_12 <- as.data.frame(st_distance(x = st_geometry(Hogares), y = st_geometry(ZATCentroids)))
rownames(mat_straight_12) <- Hogares$cod_hog
colnames(mat_straight_12) <- ZAT$ZAT
mat_straight_12_table <- as.data.frame(as.table(as.matrix(mat_straight_12)))
colnames(mat_straight_12_table) <- c("cod_hog", "zat_des", "dist_straight")

# 2 --> 1 (ZAT --> Hogar) 
mat_straight_21 <- as.data.frame(st_distance(x = st_geometry(ZATCentroids), y = st_geometry(Hogares)))
rownames(mat_straight_21) <- ZAT$ZAT
colnames(mat_straight_21) <- Hogares$cod_hog
mat_straight_21_table <- as.data.frame(as.table(as.matrix(mat_straight_21)))
colnames(mat_straight_21_table) <- c("zat_ori", "cod_hog", "dist_straight")

# 2 --> 2 (ZAT --> ZAT) 
mat_straight_22 <- as.data.frame(st_distance(x = st_geometry(ZATCentroids), y = st_geometry(ZATCentroids)))
rownames(mat_straight_22) <- ZAT$ZAT
colnames(mat_straight_22) <- ZAT$ZAT
mat_straight_22_table <- as.data.frame(as.table(as.matrix(mat_straight_22)))
colnames(mat_straight_22_table) <- c("zat_ori", "zat_des", "dist_straight")

#TRANSMILENIO
# 1 --> 2 (Hogar --> ZAT) 
mat_transmi_12 <- st_network_cost(net_transmi, from = st_geometry(Hogares), to = st_geometry(ZATCentroids))
rownames(mat_transmi_12) <- Hogares$cod_hog
colnames(mat_transmi_12) <- ZAT$ZAT
mat_transmi_12_table <- as.data.frame(as.table(mat_transmi_12))
colnames(mat_transmi_12_table) <- c("cod_hog", "zat_des", "dist_transmi")

# 2 --> 1 (ZAT --> Hogar) 
mat_transmi_21 <- st_network_cost(net_transmi, from = st_geometry(ZATCentroids), to = st_geometry(Hogares))
rownames(mat_transmi_21) <- ZAT$ZAT
colnames(mat_transmi_21) <- Hogares$cod_hog
mat_transmi_21_table <- as.data.frame(as.table(mat_transmi_21))
colnames(mat_transmi_21_table) <- c("zat_ori", "cod_hog", "dist_transmi")

# 2 --> 2 (ZAT --> ZAT) 
mat_transmi_22 <- st_network_cost(net_transmi, from = st_geometry(ZATCentroids), to = st_geometry(ZATCentroids))
rownames(mat_transmi_22) <- ZAT$ZAT
colnames(mat_transmi_22) <- ZAT$ZAT
mat_transmi_22_table <- as.data.frame(as.table(mat_transmi_22))
colnames(mat_transmi_22_table) <- c("zat_ori", "zat_des", "dist_transmi")

#MOTORIZADO
# 1 --> 2 (Hogar --> ZAT) (10 secs)
mat_mot_12 <- dodgr_dists(graph = net_mot, from = as.data.frame(st_coordinates(Hogares)), to = as.data.frame(st_coordinates(ZATCentroids)), shortest = TRUE)
rownames(mat_mot_12) <- Hogares$cod_hog
colnames(mat_mot_12) <- ZAT$ZAT
mat_mot_12[is.na(mat_mot_12)] <- mat_straight_12[is.na(mat_mot_12)]
mat_mot_12_table <- as.data.frame(as.table(mat_mot_12))
colnames(mat_mot_12_table) <- c("cod_hog", "zat_des", "dist_car")

# 2 --> 1 (ZAT --> Hogar) (10 secs)
mat_mot_21 <- dodgr_dists(graph = net_mot, from = as.data.frame(st_coordinates(ZATCentroids)), to = as.data.frame(st_coordinates(Hogares)), shortest = TRUE)
rownames(mat_mot_21) <- ZAT$ZAT
colnames(mat_mot_21) <- Hogares$cod_hog
mat_mot_21[is.na(mat_mot_21)] <- mat_straight_21[is.na(mat_mot_21)]
mat_mot_21_table <- as.data.frame(as.table(mat_mot_21))
colnames(mat_mot_21_table) <- c("zat_ori", "cod_hog", "dist_car")

# 2 --> 2 (ZAT --> ZAT) (10 secs)
mat_mot_22 <- dodgr_dists(graph = net_mot, from = as.data.frame(st_coordinates(ZATCentroids)), to = as.data.frame(st_coordinates(ZATCentroids)), shortest = TRUE)
rownames(mat_mot_22) <- ZAT$ZAT
colnames(mat_mot_22) <- ZAT$ZAT
mat_mot_22[is.na(mat_mot_22)] <- mat_straight_22[is.na(mat_mot_22)]
mat_mot_22_table <- as.data.frame(as.table(mat_mot_22))
colnames(mat_mot_22_table) <- c("zat_ori", "zat_des", "dist_car")

#BICI
# 1 --> 2 (Hogar --> ZAT) (10 secs)
mat_cycl_12 <- dodgr_dists(graph = net_cycl, from = as.data.frame(st_coordinates(Hogares)), to = as.data.frame(st_coordinates(ZATCentroids)), shortest = TRUE)
rownames(mat_cycl_12) <- Hogares$cod_hog
colnames(mat_cycl_12) <- ZAT$ZAT
mat_cycl_12[is.na(mat_cycl_12)] <- mat_straight_12[is.na(mat_cycl_12)]
mat_cycl_12_table <- as.data.frame(as.table(mat_cycl_12))
colnames(mat_cycl_12_table) <- c("cod_hog", "zat_des", "dist_bike")

# 2 --> 1 (ZAT --> Hogar) (10 secs)
mat_cycl_21 <- dodgr_dists(graph = net_cycl, from = as.data.frame(st_coordinates(ZATCentroids)), to = as.data.frame(st_coordinates(Hogares)), shortest = TRUE)
rownames(mat_cycl_21) <- ZAT$ZAT
colnames(mat_cycl_21) <- Hogares$cod_hog
mat_cycl_21[is.na(mat_cycl_21)] <- mat_straight_21[is.na(mat_cycl_21)]
mat_cycl_21_table <- as.data.frame(as.table(mat_cycl_21))
colnames(mat_cycl_21_table) <- c("zat_ori", "cod_hog", "dist_bike")

# 2 --> 2 (ZAT --> ZAT) (10 secs)
mat_cycl_22 <- dodgr_dists(graph = net_cycl, from = as.data.frame(st_coordinates(ZATCentroids)), to = as.data.frame(st_coordinates(ZATCentroids)), shortest = TRUE)
rownames(mat_cycl_22) <- ZAT$ZAT
colnames(mat_cycl_22) <- ZAT$ZAT
mat_cycl_22[is.na(mat_cycl_22)] <- mat_straight_22[is.na(mat_cycl_22)]
mat_cycl_22_table <- as.data.frame(as.table(mat_cycl_22))
colnames(mat_cycl_22_table) <- c("zat_ori", "zat_des", "dist_bike")

#WALK
# 1 --> 2 (Hogar --> ZAT) (10 secs)
mat_walk_12 <- dodgr_dists(graph = net_walk, from = as.data.frame(st_coordinates(Hogares)), to = as.data.frame(st_coordinates(ZATCentroids)), shortest = TRUE)
rownames(mat_walk_12) <- Hogares$cod_hog
colnames(mat_walk_12) <- ZAT$ZAT
mat_walk_12[is.na(mat_walk_12)] <- mat_straight_12[is.na(mat_walk_12)]
mat_walk_12_table <- as.data.frame(as.table(mat_walk_12))
colnames(mat_walk_12_table) <- c("cod_hog", "zat_des", "dist_walk")

# 2 --> 1 (ZAT --> Hogar) (10 secs)
mat_walk_21 <- dodgr_dists(graph = net_walk, from = as.data.frame(st_coordinates(ZATCentroids)), to = as.data.frame(st_coordinates(Hogares)), shortest = TRUE)
rownames(mat_walk_21) <- ZAT$ZAT
colnames(mat_walk_21) <- Hogares$cod_hog
mat_walk_21[is.na(mat_walk_21)] <- mat_straight_21[is.na(mat_walk_21)]
mat_walk_21_table <- as.data.frame(as.table(mat_walk_21))
colnames(mat_walk_21_table) <- c("zat_ori", "cod_hog", "dist_walk")

# 2 --> 2 (ZAT --> ZAT) (10 secs)
mat_walk_22 <- dodgr_dists(graph = net_walk, from = as.data.frame(st_coordinates(ZATCentroids)), to = as.data.frame(st_coordinates(ZATCentroids)), shortest = TRUE)
rownames(mat_walk_22) <- ZAT$ZAT
colnames(mat_walk_22) <- ZAT$ZAT
mat_walk_22[is.na(mat_walk_22)] <- mat_straight_22[is.na(mat_walk_22)]
mat_walk_22_table <- as.data.frame(as.table(mat_walk_22))
colnames(mat_walk_22_table) <- c("zat_ori", "zat_des", "dist_walk")

print(Sys.time())
```

## Union de las matrices con la base de viajes

```{r Unión con las bases de viajes (todo menos SITP), eval = TRUE}
colnames(viajes)[colnames(viajes) == "cod_hg"] <- "cod_hog"

#Separando la base en 3 sub-bases de acuerdo al lugar de origen y destino

viajes_12 <- viajes %>% filter(test_origen_destino == "HOGAR_Otro")
viajes_21 <- viajes %>% filter(test_origen_destino == "Otro_HOGAR")
viajes_22 <- viajes %>% filter(test_origen_destino == "Otro_Otro")

#Unión por columnas múltiples (15 min)

print(Sys.time())

viajes_12 <- merge(viajes_12, mat_mot_12_table, by = c("cod_hog", "zat_des")) 
viajes_21 <- merge(viajes_21, mat_mot_21_table, by = c("cod_hog", "zat_ori")) 
viajes_22 <- merge(viajes_22, mat_mot_22_table, by = c("zat_ori", "zat_des")) 

viajes_12 <- merge(viajes_12, mat_cycl_12_table, by = c("cod_hog", "zat_des")) 
viajes_21 <- merge(viajes_21, mat_cycl_21_table, by = c("cod_hog", "zat_ori")) 
viajes_22 <- merge(viajes_22, mat_cycl_22_table, by = c("zat_ori", "zat_des")) 

viajes_12 <- merge(viajes_12, mat_walk_12_table, by = c("cod_hog", "zat_des")) 
viajes_21 <- merge(viajes_21, mat_walk_21_table, by = c("cod_hog", "zat_ori")) 
viajes_22 <- merge(viajes_22, mat_walk_22_table, by = c("zat_ori", "zat_des")) 

viajes_12 <- merge(viajes_12, mat_transmi_12_table, by = c("cod_hog", "zat_des")) 
viajes_21 <- merge(viajes_21, mat_transmi_21_table, by = c("cod_hog", "zat_ori")) 
viajes_22 <- merge(viajes_22, mat_transmi_22_table, by = c("zat_ori", "zat_des")) 

viajes_12 <- merge(viajes_12, mat_straight_12_table, by = c("cod_hog", "zat_des")) 
viajes_21 <- merge(viajes_21, mat_straight_21_table, by = c("cod_hog", "zat_ori")) 
viajes_22 <- merge(viajes_22, mat_straight_22_table, by = c("zat_ori", "zat_des"))

print(Sys.time())
```


```{r Asignacion distancia por modo, eval = TRUE}
viajes_dist <- rbind(viajes_12, viajes_21, viajes_22)

viajes_dist$Distancia <- viajes_dist$dist_car

viajes_dist$Distancia[viajes_dist$modo_principal_typo == "TransMilenio"] <- viajes_dist$dist_transmi[viajes_dist$modo_principal_typo == "TransMilenio"]

viajes_dist$Distancia[viajes_dist$modo_principal_typo == "A pie"] <- viajes_dist$dist_walk[viajes_dist$modo_principal_typo == "A pie"]

viajes_dist$Distancia[viajes_dist$modo_principal_typo %in% c("Bicicleta")] <- viajes_dist$dist_bike[viajes_dist$modo_principal_typo %in% c("Bicicleta")]

#viajes_dist$Distancia <- as.numeric(viajes_dist$Distancia)
```

## Distancia de acceso hasta y desde TransMilenio

```{r abriendo backup, eval = TRUE}
viajes_dist <- read.xlsx("viajes_dist_no_corr.xlsx")
```

Para los viajes en Transmilenio, dado que la distancia desde el punto de partida hasta la estación, y desde la estación hasta el punto de llegada, pueden ser largas, calculamos además la distancia por la red vial con ponderación peatón entre estos puntos, y la vamos sumando a la distancia calculada por la red troncal. El cálculo se realiza entonces con _dodgr_. 

```{r distancia hasta y desde el transmi}
plot(net_transmi)

#Conversion de nudos de la red en formato sf. Incluye 140 estaciones + 25 nudos correspondientes a extremidades de ejes que no pudieron ser evitados en la construcción de la red
acceso_transmi <- net_transmi %>%
  activate("nodes") %>%
  st_geometry() %>%
  st_as_sf()

#Matriz de distancias a pie entre hogares y estaciones
mat_walk_hog_transmi <- dodgr_dists(graph = net_walk, from = as.data.frame(st_coordinates(Hogares)), to = as.data.frame(st_coordinates(acceso_transmi)), shortest = TRUE)
rownames(mat_walk_hog_transmi) <- Hogares$cod_hog
colnames(mat_walk_hog_transmi) <- rownames(acceso_transmi)

#Búsqueda de la estación de Transmilenio más cercana a cada hogar
distancia <- apply(mat_walk_hog_transmi[,1:dim(mat_walk_hog_transmi)[2]], FUN = min, MARGIN = 1)
name <- data.frame(name = colnames(mat_walk_hog_transmi)[apply(mat_walk_hog_transmi, 1, function(x) which(x == min(x))[1])])
estacion_mas_cerca_hogar <- cbind(name, distancia)
estacion_mas_cerca_hogar$cod_hog <- as.numeric(rownames(estacion_mas_cerca_hogar))

#Matriz de distancias a pie entre centroides de ZAT y estaciones
mat_walk_centroid_transmi <- dodgr_dists(graph = net_walk, from = as.data.frame(st_coordinates(ZATCentroids)), to = as.data.frame(st_coordinates(acceso_transmi)), shortest = TRUE)
rownames(mat_walk_centroid_transmi) <- ZAT$ZAT
colnames(mat_walk_centroid_transmi) <- rownames(acceso_transmi)

#Búsqueda de la estación de Transmilenio más cercana a cada centroide de ZAT
distancia <- apply(mat_walk_centroid_transmi[,1:dim(mat_walk_centroid_transmi)[2]], FUN = min, MARGIN = 1)
name <- data.frame(name = colnames(mat_walk_centroid_transmi)[apply(mat_walk_centroid_transmi, 1, function(x) which(x == min(x))[1])])
estacion_mas_cerca_centroid <- cbind(name, distancia)
estacion_mas_cerca_centroid$ZAT <- as.numeric(rownames(estacion_mas_cerca_centroid))

#Adición de la distancia hasta y desde Transmilenio en los viajes con este modo
Hog_TM <- viajes_dist %>% left_join(estacion_mas_cerca_hogar[,c("cod_hog", "distancia")], by = "cod_hog") %>%
  group_by(cod_hog) %>%
  summarize(dist_Hog_TM = unique(distancia), dist_TM_Hog = unique(distancia))

ZAT_TM <- viajes_dist %>% left_join(estacion_mas_cerca_centroid[,c("ZAT", "distancia")], by = c("zat_ori" = "ZAT")) %>%
  group_by(zat_ori) %>%
  summarize(dist_ZAT_TM = unique(distancia))

TM_ZAT <- viajes_dist %>% left_join(estacion_mas_cerca_centroid[,c("ZAT", "distancia")], by = c("zat_des" = "ZAT")) %>%
  group_by(zat_des) %>%
  summarize(dist_TM_ZAT = unique(distancia))

viajes_dist <- viajes_dist %>% 
  left_join(Hog_TM, by = "cod_hog") %>%
  left_join(ZAT_TM, by = "zat_ori") %>%
  left_join(TM_ZAT, by = "zat_des")

viajes_dist$dist_hasta_TM[viajes_dist$test_origen_destino == "HOGAR_Otro"] <- viajes_dist$dist_Hog_TM[viajes_dist$test_origen_destino == "HOGAR_Otro"]
viajes_dist$dist_hasta_TM[viajes_dist$test_origen_destino %in% c("Otro_HOGAR", "Otro_Otro")] <- viajes_dist$dist_ZAT_TM[viajes_dist$test_origen_destino %in% c("Otro_HOGAR", "Otro_Otro")]
viajes_dist$dist_desde_TM[viajes_dist$test_origen_destino == "Otro_HOGAR"] <- viajes_dist$dist_TM_Hog[viajes_dist$test_origen_destino == "Otro_HOGAR"]
viajes_dist$dist_desde_TM[viajes_dist$test_origen_destino %in% c("HOGAR_Otro", "Otro_Otro")] <- viajes_dist$dist_TM_ZAT[viajes_dist$test_origen_destino %in% c("HOGAR_Otro", "Otro_Otro")]
```

## Distancia a pie dentro de viajes con el SITP Zonal

Para los viajes con el SITP Zonal, el paquete _r5r_ permitió calcular itinerarios detallados incluyendo los tramos a pie y dentro de los buses. Tenemos entonces las distancias de acceso hasta y desde el paradero, y las distancias caminadas para realizar trasbordo entre rutas. 

```{r distancia SITP, eval = TRUE}
#Las distancias por la red SITP fueron calculadas en otro markdown "Distancias_SITP_r5r.Rmd"
viajes_sitp <- openxlsx::read.xlsx("r5r/viajes_sitp.xlsx")

viajes_dist$dist_sitp = NULL
colnames(viajes_sitp) <- c("cod_vj", "dist_bus_sitp_zonal", "dist_caminata_sitp_zonal", "dist_total_sitp_zonal")

viajes_dist <- viajes_dist %>% left_join(viajes_sitp, by = "cod_vj")

viajes_dist$Distancia[viajes_dist$modo_principal_typo == "SITP Zonal"] <- viajes_dist$dist_bus_sitp_zonal[viajes_dist$modo_principal_typo == "SITP Zonal"]

#385 viajes en SITP que r5r no pudo calcular la distancia.
viajes_dist$Distancia[is.na(viajes_dist$Distancia)] <- viajes_dist$dist_car[is.na(viajes_dist$Distancia)] 
```

385 viajes dentro de los realizados en SITP no pudieron ser hallados, sumando 52,216 viajes, es decir el 2.3% de los viajes en SITP Zonal. Se les asigna el valor para el auto.

Hallamos la distancia promedio desde cada red hasta los puntos de la matriz (con resolución 200m).

```{r comparacion distancias a los distintos puntos de acceso a las redes, eval = TRUE}
comparacion <- data.frame(red = c("Transmilenio - Hogar","Transmilenio - ZAT","Caminata SITP"),
                          dist_promedio_desde_matriz = c(mean(Hog_TM$dist_Hog_TM),
                                                         mean(ZAT_TM$dist_ZAT_TM),
                                                         mean(viajes_dist$dist_caminata_sitp_zonal, na.rm = TRUE)),
                          dist_mediana_desde_matriz = c(median(Hog_TM$dist_Hog_TM),
                                                         median(ZAT_TM$dist_ZAT_TM),
                                                         median(viajes_dist$dist_caminata_sitp_zonal, na.rm = TRUE)))

colnames(comparacion) <- c("Red", "Promedio", "Mediana")

kable(comparacion, caption = "Comparación de las distancias entre los Hogares, los centroides de ZAT y las redes de transporte colectivo", format.args = list(big.mark = ","))
```

## Viajes internos a las zonas

Para los viajes internos a las zonas ("intrazona"), dos metodos fueron probados en la base de la EODH 2019:

* El método "del CEREMA". La distancia de cada viaje es la media raiz cuadrada del area de la zona.
* El método "de la media". Se sortean 10 puntos en cada ZAT y calcula la distancia entre cada par de origen-destino por la red vial con ponderación peatón (ya que 810 de 1255 viajes internos (65%) se realizan con este modo). Luego se asigna al viaje la distancia correspondiente al promedio de los valores calculados excluyendo los ceros.

En nuestro caso, escogemos el método "de la media" que tiende a dar estimaciones superiores al método "del CEREMA".

Para el caso de los viajes intrazonas en Transmilenio, el criterio para detectarlos es que la distancia por la red de Transmilenio sea nula.


```{r Trayectos intrazonas metodo de la media, eval = TRUE}
#Seleccion de las ZAT que tienen trayectos internos
viajes_intra <- viajes_dist[viajes_dist$zat_ori == viajes_dist$zat_des & viajes_dist$Distancia == 0,c("zat_ori", "zat_des", "cod_vj", "modo_principal_typo")]
viajes_intra$id_row <- 1:nrow(viajes_intra)
ZAT_intra <- ZAT[ZAT$ZAT %in% as.numeric(unique(viajes_intra$zat_des)),]

#Tomando muestra en cada ZAT seleccionada
#Tamaño de la muestra
s <- 10
d <- nrow(ZAT_intra)

set.seed(1)
ZATSampled <- st_sample(ZAT_intra, rep(s,d))

ZATSampled <- st_sf(ZATSampled) %>%
  st_join(ZAT[,"ZAT"],
          join = st_intersects)

ZATSampled$row <- rep(c(1:s),d)

#Calculando la matriz de distancias por la red vial, ponderación peatón
mat_intra <- dodgr_dists(graph = net_walk, from = as.data.frame(st_coordinates(ZATSampled)), to = as.data.frame(st_coordinates(ZATSampled)), shortest = TRUE)

rownames(mat_intra) <- ZATSampled$ZAT
colnames(mat_intra) <- ZATSampled$ZAT

comb <- function(z) {
  merge(viajes_intra, z, by = c("zat_ori","zat_des")) %>% 
    arrange(id_row) %>%
    dplyr::select(c(-zat_ori,-zat_des, -cod_vj, -modo_principal_typo, -id_row))
}

doFuture::registerDoFuture()
future::plan(multisession, workers = 8)
options(future.globals.maxSize= 1048576000)

viajes2 <- foreach(u = 1:s, .combine = 'cbind') %:%
  foreach(v = 1:s, .combine = 'cbind') %dofuture% {
    subset_i = seq(from = u, to = s*d, by = s)
    subset_j = seq(from = v, to = s*d, by = s)
    z <- mat_intra[subset_i,subset_j]
    colnames(z) <- ZAT_intra$ZAT
    rownames(z) <- ZAT_intra$ZAT
    z <- data.frame(rownames(as.matrix(z))[row(as.matrix(z))], 
               colnames(as.matrix(z))[col(as.matrix(z))], 
               c(as.matrix(z)))
    colnames(z) <- c("zat_ori", "zat_des", paste0("dist",(u-1)*s+(v-1)))
    x <- comb(z)
  }

viajes_intra <- cbind(viajes_intra,viajes2)

#índices de las columnas con distancia interna igual a cero
index_zero <- rep("VIDE",s)
for(i in 1:s){
    index_zero[i] <- paste0("dist",(i-1)*s+(i-1))
}

#Distancia interna = promedio de las distancias excluyendo los ceros.
viajes_intra_non_zero <- viajes_intra[,!(colnames(viajes_intra) %in% index_zero)]
viajes_intra$dist_mean_non_zeros <- rowMeans(viajes_intra_non_zero[,6:95], na.rm = TRUE)

#Sustituyendo los ceros en la base de distancias
viajes_dist$Distancia[viajes_dist$zat_ori == viajes_dist$zat_des & viajes_dist$Distancia == 0] <- viajes_intra$dist_mean_non_zeros
```

## Viajes de ida y vuelta

Identificamos los viajes de ida y vuelta. Un viaje de ida y vuelta se identifica porque cumple las siguientes características:

* Se buscan tales viajes dentro del conjunto de viajes realizados por una misma persona identificada por su _cod_hog_. 
* Para cada persona, creamos una submuestra correspondiente a los potenciales viajes "de ida", que son los que originan en su casa, y otra submuesta correspondiente a los potenciales viajes "de vuelta".
* Se unen las dos submuestras por _cod_hog_ y se comparan el modo de los dos viajes (deben coincidir para que sea ida y vuelta), el lugar de destino del viaje de ida y el lugar de origen del viaje de regreso (deben coincidir para que sea ida y vuelta).
* Finalmente, se crea una variable dummy en la base de viajes completa indicando si cada viaje es parte de una ida y vuelta o no.

Nota: dado que no pudimos identificar todos los viajes que inician en el hogar, sino solo el primero del día, este algoritmo solo puede detectar máximo una ida y vuelta por persona

```{r identificación ida y vuelta, eval = TRUE}
#Esta etapa es necesaria en el marco del control de velocidad de la siguiente etapa. Se define como ida y vuelta un trayecto casa -> cierto lugar -> casa realizado con el mismo modo de transporte. El lugar de destino del primer viaje y el lugar de origen del segundo deben coincidir. Lo mismo con la zat de destino del primer viaje y la zat de orgigen del segundo. Si el modo de transporte cambia, no lo definimos como ida y vuelta.

ida <- viajes_dist[viajes_dist$lugar_origen == "Hogar", c("cod_pers", "cod_vj", "lugar_destino", "zat_des", "modo_principal_typo")]
vuelta <- viajes_dist[viajes_dist$lugar_destino == "Hogar", c("cod_pers", "cod_vj", "lugar_origen", "zat_ori", "modo_principal_typo")]
ida_vuelta <- na.omit(ida %>% left_join(vuelta, by = "cod_pers"))
ida_vuelta$is_ida_vuelta <- (ida_vuelta$lugar_destino == ida_vuelta$lugar_origen) & (ida_vuelta$zat_des == ida_vuelta$zat_ori) & (ida_vuelta$modo_principal_typo.x == ida_vuelta$modo_principal_typo.y)
ida <- ida_vuelta[,c("cod_vj.x", "is_ida_vuelta")]
colnames(ida)[colnames(ida) == "cod_vj.x"] <- "cod_vj"
ida <- ida %>% group_by(cod_vj) %>% summarize(is_ida_vuelta = as.logical(max(is_ida_vuelta)))
vuelta <- ida_vuelta[,c("cod_vj.y", "is_ida_vuelta")]
colnames(vuelta)[colnames(vuelta) == "cod_vj.y"] <- "cod_vj"
vuelta <- vuelta %>% group_by(cod_vj) %>% summarize(is_ida_vuelta = as.logical(max(is_ida_vuelta)))
viajes_dist <- viajes_dist %>% left_join(ida, by = c("cod_vj"))
viajes_dist <- viajes_dist %>% left_join(vuelta, by = c("cod_vj"))
viajes_dist$is_ida_vuelta.x[is.na(viajes_dist$is_ida_vuelta.x)] <- FALSE
viajes_dist$is_ida_vuelta.y[is.na(viajes_dist$is_ida_vuelta.y)] <- FALSE
viajes_dist$is_ida_vuelta <- viajes_dist$is_ida_vuelta.x | viajes_dist$is_ida_vuelta.y
viajes_dist$is_ida_vuelta.x <- NULL
viajes_dist$is_ida_vuelta.y <- NULL
```


## Control de velocidad

```{r Control velocidad, eval = TRUE}
#velocidad en km/h
viajes_dist$velocidad <- 60*viajes_dist$Distancia/(1000*viajes_dist$duracion_min)

#8139 viajes a pie son demasiado rápidos (23%)
viajes_dist$Distancia[viajes_dist$modo_principal_typo == "A pie" & viajes_dist$velocidad > 10] <- 1000*viajes_dist$duracion_min[viajes_dist$modo_principal_typo == "A pie" & viajes_dist$velocidad > 10]*10/60

#250 viajes en bici son demasiado rápidos (5%)
viajes_dist$Distancia[viajes_dist$modo_principal_typo == "Bicicleta" & viajes_dist$velocidad > 30] <- 1000*viajes_dist$duracion_min[viajes_dist$modo_principal_typo == "Bicicleta" & viajes_dist$velocidad > 30]*30/60

#963 viajes en modos motorizados son demasiado rápidos (2%)
viajes_dist$Distancia[!(viajes_dist$modo_principal_typo %in% c("A pie","Bicicleta")) & viajes_dist$velocidad > 50] <- 1000*viajes_dist$duracion_min[!(viajes_dist$modo_principal_typo %in% c("A pie","Bicicleta")) & viajes_dist$velocidad > 50]*50/60

#se aplica una ultima correccion: los viajes de ida y vuelta deben tener la misma distancia. Se corrige la distancia de los viajes demasiado rápidos, pero en el caso de los viajes de ida y vuelta, dado que esperamos que la distancia coincida en la ida y el regreso, le vamos a asignar el maximo entre los dos valores.
ida_vuelta <- viajes_dist[viajes_dist$is_ida_vuelta == TRUE,] %>% 
  group_by(cod_pers, modo_principal_typo) %>%
  summarise(Distancia_AR = max(Distancia))
viajes_dist <- viajes_dist %>% left_join(ida_vuelta, by = c("cod_pers", "modo_principal_typo"))
viajes_dist$Distancia[viajes_dist$is_ida_vuelta == TRUE] <- viajes_dist$Distancia_AR[viajes_dist$is_ida_vuelta == TRUE]
viajes_dist$Distancia_AR <- NULL
viajes_dist$velocidad <- NULL
```


## Base final

```{r distancia incluyendo la caminata inicial y final, eval = TRUE}
viajes_dist$Distancia_incl_caminata <- viajes_dist$Distancia

viajes_dist$Distancia_incl_caminata[viajes_dist$modo_principal_typo == "TransMilenio"] <- viajes_dist$Distancia[viajes_dist$modo_principal_typo == "TransMilenio"] + viajes_dist$dist_hasta_TM[viajes_dist$modo_principal_typo == "TransMilenio"] + viajes_dist$dist_desde_TM[viajes_dist$modo_principal_typo == "TransMilenio"]

viajes_dist$Distancia_incl_caminata[viajes_dist$modo_principal_typo == "SITP Zonal"] <- viajes_dist$dist_total_sitp_zonal[viajes_dist$modo_principal_typo == "SITP Zonal"]

viajes_dist$Distancia_incl_caminata[is.na(viajes_dist$Distancia_incl_caminata)] <- viajes_dist$Distancia[is.na(viajes_dist$Distancia_incl_caminata)]
```

Por fin podemos crear la base final con las variables correspondientes a distancia, emisiones de gases de efecto invernadero y contaminantes aéreos.


```{r Base final, eval = TRUE}
viajes_dist <- viajes_dist %>% left_join(EF, by = c("modo_principal_typo" = "modo_principal"))

viajes_dist$`CO2-eq` <- viajes_dist$`CO2-eq`*viajes_dist$Distancia/1000
viajes_dist$CO <- viajes_dist$CO*viajes_dist$Distancia/1000
viajes_dist$NOx <- viajes_dist$NOx*viajes_dist$Distancia/1000
viajes_dist$SO2 <- viajes_dist$SO2*viajes_dist$Distancia/1000
viajes_dist$COV <- viajes_dist$COV*viajes_dist$Distancia/1000
viajes_dist$PM.2.5 <- viajes_dist$PM.2.5*viajes_dist$Distancia/1000
viajes_dist$PM.10 <- viajes_dist$PM.10*viajes_dist$Distancia/1000

#write.xlsx(viajes_dist, paste0("viajes_dist_final_con_caminata_hasta_TM.xlsx"), overwrite = TRUE)
```

# Estadísticas

```{r stat modos}
viajes_dist <- read.xlsx("viajes_dist_final_con_caminata_hasta_TM.xlsx")

estadisticas <- viajes_dist %>% 
  group_by(modo_principal_typo) %>% 
  summarize(numero_viajes = round(sum(fexp_vj),0), 
            mpkt = sum(fexp_vj*Distancia/1000000000),
            mpkt_incl_caminata = sum(fexp_vj*Distancia_incl_caminata/1000000000),
            reparto_modal = 100*sum(fexp_vj)/sum(viajes_dist$fexp_vj), 
            reparto_modal_pkt = 100*sum(fexp_vj*Distancia_incl_caminata)/sum(viajes_dist$fexp_vj*viajes_dist$Distancia_incl_caminata), 
            `CO2-eq`= sum(fexp_vj*`CO2-eq`/1000000),
            dist_por_viaje = sum(fexp_vj*Distancia_incl_caminata/1000)/sum(fexp_vj),
            duracion_por_viaje = sum(fexp_vj*duracion_min)/sum(fexp_vj))
  
estadisticas <- estadisticas[order(estadisticas$numero_viajes, decreasing = TRUE),]

#write.xlsx(estadisticas, "estadisticas_modos_bogota_2023.xlsx", overwrite = TRUE)

total <- data.frame("TOTAL", 
                   sum(estadisticas$numero_viajes),
                   sum(estadisticas$mpkt),
                   sum(estadisticas$mpkt_incl_caminata),
                   sum(estadisticas$reparto_modal),
                   sum(estadisticas$reparto_modal_pkt),
                   sum(estadisticas$`CO2-eq`),
                   sum(estadisticas$numero_viajes*estadisticas$dist_por_viaje)/sum(estadisticas$numero_viajes),
                   sum(estadisticas$numero_viajes*estadisticas$duracion_por_viaje)/sum(estadisticas$numero_viajes))

colnames(total) <- colnames(estadisticas)

estadisticas <- rbind(estadisticas, total)

colnames(estadisticas) <- c("Modo principal","Número de viajes","Millón PKT (solo tramo principal)", "Millón PKT (total incluyendo caminata inicial y final)","% Número de viajes","% PKT","Emisiones GEI (tCO2-eq)", "Distancia media por viaje (km)", "Duracion media por viaje (min)")

kable(estadisticas, caption = "Estadísticas por modo", format.args = list(big.mark = ","), digits = 1) 
```

```{r stats motivos}
motivos <- data.frame(motivo_viaje = unique(viajes_dist$motivo_viaje),
                      motivo = c("Trabajo", "Retorno a casa", "Compras", "Estudio", "Salud", "Trámites", "Acompañamiento", "Otro", "Otro", "Visita",  "Otro", "Otro", "Otro", "Otro", "Otro", "Otro"))

viajes_dist <- viajes_dist %>% left_join(motivos, by = "motivo_viaje")

estadisticas <- viajes_dist %>% 
  group_by(motivo) %>% 
  summarize(numero_viajes = round(sum(fexp_vj),0), 
            mpkt = sum(fexp_vj*Distancia/1000000000),
            mpkt_incl_caminata = sum(fexp_vj*Distancia_incl_caminata/1000000000),
            reparto_modal = 100*sum(fexp_vj)/sum(viajes_dist$fexp_vj), 
            reparto_modal_pkt = 100*sum(fexp_vj*Distancia_incl_caminata)/sum(viajes_dist$fexp_vj*viajes_dist$Distancia_incl_caminata), 
            `CO2-eq`= sum(fexp_vj*`CO2-eq`/1000000),
            dist_por_viaje = sum(fexp_vj*Distancia_incl_caminata/1000)/sum(fexp_vj),
            duracion_por_viaje = sum(fexp_vj*duracion_min)/sum(fexp_vj))
  
estadisticas <- estadisticas[order(estadisticas$numero_viajes, decreasing = TRUE),]

#write.xlsx(estadisticas, "estadisticas_motivos_bogota_2023.xlsx", overwrite = TRUE)

total <- data.frame("TOTAL", 
                   sum(estadisticas$numero_viajes),
                   sum(estadisticas$mpkt),
                   sum(estadisticas$mpkt_incl_caminata),
                   sum(estadisticas$reparto_modal),
                   sum(estadisticas$reparto_modal_pkt),
                   sum(estadisticas$`CO2-eq`),
                   sum(estadisticas$numero_viajes*estadisticas$dist_por_viaje)/sum(estadisticas$numero_viajes),
                   sum(estadisticas$numero_viajes*estadisticas$duracion_por_viaje)/sum(estadisticas$numero_viajes))

colnames(total) <- colnames(estadisticas)

estadisticas <- rbind(estadisticas, total)

colnames(estadisticas) <- c("Motivo","Número de viajes","Millón PKT (solo tramo principal)", "Millón PKT (total incluyendo caminata inicial y final)","% Número de viajes","% PKT","Emisiones GEI (tCO2-eq)", "Distancia media por viaje (km)", "Duracion media por viaje (min)")

kable(estadisticas, caption = "Estadísticas por motivo", format.args = list(big.mark = ","), digits = 1)
```


# Cartografía

Finalmente, producimos mapas por zonas (UTAM).

```{r nombres para ser mostrados big labs, eval = TRUE}
centroides_limites_bogota <- st_centroid(limites_bogota) %>%
  mutate(lon = st_coordinates(.)[,1],
         lat = st_coordinates(.)[,2]) 

centroides_limites_bogota$MUNI <- centroides_limites_bogota$NOMBRE
centroides_limites_bogota$MUNI[centroides_limites_bogota$NOMBR_MUNI == "BOGOTA"] <- ""

centroides_limites_bogota$LOCA <- centroides_limites_bogota$NOMBRE
centroides_limites_bogota$LOCA[centroides_limites_bogota$NOMBR_MUNI != "BOGOTA"] <- ""

centroides_limites_bogota$DISPLAY <- centroides_limites_bogota$NOMBRE
centroides_limites_bogota$DISPLAY[!((centroides_limites_bogota$NOMBR_MUNI == "BOGOTA"  & centroides_limites_bogota$NOMBRE %in% c("BOSA", "SANTA FE", "CIUDAD BOLIVAR", "TEUSAQUILLO", "FONTIBON", "ENGATIVA", "SUBA", "USAQUEN", "USME", "SAN CRISTOBAL", "CHAPINERO", "KENNEDY")) | (centroides_limites_bogota$NOMBR_MUNI != "BOGOTA"))] <- ""

centroides_limites_bogota$DISPLAY[centroides_limites_bogota$NOMBR_MUNI %in% c("SIBATE", "SUBACHOQUE")] <- ""
 
centroides_limites_bogota$DISPLAY[centroides_limites_bogota$NOMBRE %in% c("LA CALERA", "GACHANCIPA")] <- ""

centroides_limites_bogota$lat[centroides_limites_bogota$NOMBRE == "SUBA"] <- 4.76
centroides_limites_bogota$lat[centroides_limites_bogota$NOMBRE == "SOACHA"] <- 4.60
centroides_limites_bogota$lon[centroides_limites_bogota$NOMBRE == "CHAPINERO"] <- -74.027
centroides_limites_bogota$lat[centroides_limites_bogota$NOMBRE == "USAQUEN"] <- 4.74
centroides_limites_bogota$lat[centroides_limites_bogota$NOMBRE == "CHAPINERO"] <- 4.68
centroides_limites_bogota$lat[centroides_limites_bogota$NOMBRE == "TEUSAQUILLO"] <- 4.65
centroides_limites_bogota$lat[centroides_limites_bogota$NOMBRE == "KENNEDY"] <- 4.635
centroides_limites_bogota$lat[centroides_limites_bogota$NOMBRE == "CIUDAD BOLIVAR"] <- 4.58
centroides_limites_bogota$DISPLAY[centroides_limites_bogota$NOMBRE == "CIUDAD BOLIVAR"] <- "CIUDAD \nBOLIVAR"

centroides_limites_bogota <- centroides_limites_bogota %>% st_drop_geometry() %>% st_as_sf(coords = c("lon", "lat"), crs = st_crs(4326))
```
```{r Poblacion por zat}
ZAT_Poblacion <- Personas %>%
  group_by(zat_hg) %>%
  summarize(pop = sum(`fexp_per>5años`))

ZAT <- ZAT %>% left_join(ZAT_Poblacion, by = c("ZAT" = "zat_hg"))
ZAT$pop[is.na(ZAT$pop)] <- 0
```

## Cartografía en español (ggplot2)

```{r dist per capita}
UTAM <- UTAM %>% st_transform(4326)

Dist_ZAT <- viajes_dist[,c("zat_hg", "modo_principal_comparado", "Distancia_incl_caminata", "fexp_vj")]%>%
  left_join(ZAT[,c("ZAT")], by = c("zat_hg" = "ZAT")) %>%
  group_by(zat_hg) %>%
  summarize(dist = sum(fexp_vj*Distancia_incl_caminata/1000))

ZAT <- ZAT %>% left_join(Dist_ZAT, by = c("ZAT" = "zat_hg"))

ZAT$dist[is.na(ZAT$dist)] <- 0

UTAM_indic <- ZAT %>% 
  st_drop_geometry() %>%
  group_by(UTAM) %>% 
  summarise(dist = sum(dist), 
           pop = sum(pop), 
           dist_capita = dist/pop)

UTAM <- UTAM %>% left_join(UTAM_indic, by = "UTAM")
```

```{r map dist per capita, fig.asp=1.3, eval = FALSE}
#Colores
bks_total <- round(as.numeric(quantile(UTAM$dist_capita, probs = c(0,0.1,0.25,0.5,0.75,0.9), na.rm = TRUE)),2)
bks <- c(bks_total,max(UTAM$dist_capita))

UTAM$binned_dist_capita <- cut(UTAM$dist_capita,bks)

ggplot()+
  theme_bw()+
  geom_sf(data = UTAM, color = NA, aes(fill = binned_dist_capita))+
  geom_sf(data = limites_bogota, fill = NA, aes(linetype = "Límite de municipio fuera de Bogotá DC \nLímite de localidad dentro de Bogotá DC"), color = "grey")+
  geom_text(data= centroides_limites_bogota,aes(x=lon, y=lat, label = DISPLAY), color = "black", fontface = "plain", size = 2.5, check_overlap = FALSE) +
  scale_fill_manual(values = brewer.pal(6,"Purples")) +
  coord_sf(xlim = lon_bounds_Bogota, ylim = lat_bounds_Bogota, datum = NA)+
  labs(title = "", fill = "Distancia cotidiana promedio per \ncápita todos modos incluidos (km)", caption = "Autor: Hugo Thomas - Université Rennes 2 / Universidad de los Andes \nFuente: Encuesta Origen-Destino de Hogares, Secretaría Distrital de Movilidad, 2023 \nDiscretización con los cuantiles 0.10, 0.25, 0.50, 0.75, 0.90", linetype = "") +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        plot.title = element_text(size = 15, face = "bold", hjust = 0.5, vjust = 0),
        legend.title = element_text(size = 13),
        legend.text = element_text(size=13),
        plot.caption = element_text(size = 9, face = "italic", hjust = 0, vjust = 62),
        legend.text.align = 1)+
  guides(linetype = guide_legend(label.hjust = 0, order = 1))+
  labs(x = "", y = "") +
  annotation_scale(location = "br", height = unit(0.2, "cm"),text_cex = 0.8) +
  annotation_north_arrow(location = "tl", which_north = "true", height = unit(1, "cm"), width = unit(1, "cm"), style = north_arrow_orienteering(text_size = 8))
```

```{r walking dist per capita}
Dist_ZAT <- viajes_dist[viajes_dist$modo_principal_comparado == "A pie",c("zat_hg", "modo_principal_comparado", "Distancia_incl_caminata", "fexp_vj")]%>%
  left_join(ZAT[,c("ZAT")], by = c("zat_hg" = "ZAT")) %>%
  group_by(zat_hg) %>%
  summarize(dist_walk = sum(fexp_vj*Distancia_incl_caminata/1000))

ZAT <- ZAT %>% left_join(Dist_ZAT, by = c("ZAT" = "zat_hg"))

ZAT$dist_walk[is.na(ZAT$dist_walk)] <- 0

UTAM_indic <- ZAT %>% 
  st_drop_geometry() %>%
  group_by(UTAM) %>% 
  summarise(dist_walk = sum(dist_walk), 
           walk_intensity = sum(dist_walk)/sum(pop))

UTAM <- UTAM %>% left_join(UTAM_indic, by = "UTAM")
```

```{r map walking, fig.asp=1.3, eval = FALSE}
#Colores
bks_walk <- round(as.numeric(quantile(UTAM$walk_intensity, probs = c(0,0.1,0.25,0.5,0.75,0.9), na.rm = TRUE)),2)
bks <- c(bks_walk,max(UTAM$walk_intensity))

UTAM$binned_walk_intensity <- cut(UTAM$walk_intensity,bks)

ggplot()+
  theme_bw()+
  geom_sf(data = UTAM, color = NA, aes(fill = binned_walk_intensity))+
  geom_sf(data = limites_bogota, fill = NA, aes(linetype = "Límite de municipio fuera de Bogotá DC \nLímite de localidad dentro de Bogotá DC"), color = "grey")+
  geom_text(data= centroides_limites_bogota,aes(x=lon, y=lat, label = DISPLAY), color = "black", fontface = "plain", size = 2.5, check_overlap = FALSE) +
  scale_fill_manual(values = brewer.pal(6,"Reds")) +
  coord_sf(xlim = lon_bounds_Bogota, ylim = lat_bounds_Bogota, datum = NA)+
  labs(title = "", fill = "Distancia cotidiana promedio \nper cápita caminando (km)", caption = "Autor: Hugo Thomas - Université Rennes 2 / Universidad de los Andes \nFuente: Encuesta Origen-Destino de Hogares, Secretaría Distrital de Movilidad, 2023 \nDiscretización con los cuantiles 0.10, 0.25, 0.50, 0.75, 0.90", linetype = "") +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        plot.title = element_text(size = 15, face = "bold", hjust = 0.5, vjust = 0),
        legend.title = element_text(size = 13),
        legend.text = element_text(size=13),
        plot.caption = element_text(size = 9, face = "italic", hjust = 0, vjust = 62),
        legend.text.align = 1)+
  guides(linetype = guide_legend(label.hjust = 0, order = 1))+
  labs(x = "", y = "") +
  annotation_scale(location = "br", height = unit(0.2, "cm"),text_cex = 0.8) +
  annotation_north_arrow(location = "tl", which_north = "true", height = unit(1, "cm"), width = unit(1, "cm"), style = north_arrow_orienteering(text_size = 8))
```

```{r car dist per capita}
Dist_ZAT <- viajes_dist[viajes_dist$modo_principal_comparado == "Auto",c("zat_hg", "modo_principal_comparado", "Distancia_incl_caminata", "fexp_vj")]%>%
  left_join(ZAT[,c("ZAT")], by = c("zat_hg" = "ZAT")) %>%
  group_by(zat_hg) %>%
  summarize(dist_auto = sum(fexp_vj*Distancia_incl_caminata/1000))

ZAT <- ZAT %>% left_join(Dist_ZAT, by = c("ZAT" = "zat_hg"))

ZAT$dist_auto[is.na(ZAT$dist_auto)] <- 0

UTAM_indic <- ZAT %>% 
  st_drop_geometry() %>%
  group_by(UTAM) %>% 
  summarise(dist_auto = sum(dist_auto), 
           auto_intensity = sum(dist_auto)/sum(pop))

UTAM <- UTAM %>% left_join(UTAM_indic, by = "UTAM")
```

```{r map car, fig.asp=1.3, eval=FALSE}
bks_car <- round(as.numeric(quantile(UTAM$auto_intensity, probs = c(0,0.1,0.25,0.5,0.75,0.9), na.rm = TRUE)),2)
bks <- c(bks_car,max(UTAM$auto_intensity))

UTAM$binned_auto_intensity <- cut(UTAM$auto_intensity,bks)

ggplot()+
  theme_bw()+
  geom_sf(data = UTAM, color = NA, aes(fill = binned_auto_intensity))+
  geom_sf(data = limites_bogota, fill = NA, aes(linetype = "Límite de municipio fuera de Bogotá DC \nLímite de localidad dentro de Bogotá DC"), color = "grey")+
  geom_text(data= centroides_limites_bogota,aes(x=lon, y=lat, label = DISPLAY), color = "black", fontface = "plain", size = 2.5, check_overlap = FALSE) +
  scale_fill_manual(values = brewer.pal(6,"RdPu")) +
  coord_sf(xlim = lon_bounds_Bogota, ylim = lat_bounds_Bogota, datum = NA)+
  labs(title = "", fill = "Distancia cotidiana promedio per \ncápita en auto particular (km)", caption = "Autor: Hugo Thomas - Université Rennes 2 / Universidad de los Andes \nFuente: Encuesta Origen-Destino de Hogares, Secretaría Distrital de Movilidad, 2023 \nDiscretización con los cuantiles 0.10, 0.25, 0.50, 0.75, 0.90", linetype = "") +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        plot.title = element_text(size = 15, face = "bold", hjust = 0.5, vjust = 0),
        legend.title = element_text(size = 13),
        legend.text = element_text(size=13),
        plot.caption = element_text(size = 9, face = "italic", hjust = 0, vjust = 62),
        legend.text.align = 1)+
  guides(linetype = guide_legend(label.hjust = 0, order = 1))+
  labs(x = "", y = "") +
  annotation_scale(location = "br", height = unit(0.2, "cm"),text_cex = 0.8) +
  annotation_north_arrow(location = "tl", which_north = "true", height = unit(1, "cm"), width = unit(1, "cm"), style = north_arrow_orienteering(text_size = 8))
```

```{r transit dist per capita}
Dist_ZAT <- viajes_dist[viajes_dist$modo_principal_comparado == "Transporte publico",c("zat_hg", "modo_principal_comparado", "Distancia_incl_caminata", "fexp_vj")]%>%
  left_join(ZAT[,c("ZAT")], by = c("zat_hg" = "ZAT")) %>%
  group_by(zat_hg) %>%
  summarize(dist_transit = sum(fexp_vj*Distancia_incl_caminata/1000))

ZAT <- ZAT %>% left_join(Dist_ZAT, by = c("ZAT" = "zat_hg"))

ZAT$dist_transit[is.na(ZAT$dist_transit)] <- 0

UTAM_indic <- ZAT %>% 
  st_drop_geometry() %>%
  group_by(UTAM) %>% 
  summarise(dist_transit = sum(dist_transit), 
           transit_intensity = sum(dist_transit)/sum(pop))

UTAM <- UTAM %>% left_join(UTAM_indic, by = "UTAM")
```

```{r map transit, fig.asp=1.3, eval = FALSE}
bks_transit <- round(as.numeric(quantile(UTAM$transit_intensity, probs = c(0,0.1,0.25,0.5,0.75,0.9), na.rm = TRUE)),3)
bks <- c(bks_transit,max(UTAM$transit_intensity))

UTAM$binned_transit_intensity <- cut(UTAM$transit_intensity,bks)

ggplot()+
  theme_bw()+
  geom_sf(data = UTAM, color = NA, aes(fill = binned_transit_intensity))+
  geom_sf(data = limites_bogota, fill = NA, aes(linetype = "Límite de municipio fuera de Bogotá DC \nLímite de localidad dentro de Bogotá DC"), color = "grey")+
  geom_text(data= centroides_limites_bogota,aes(x=lon, y=lat, label = DISPLAY), color = "black", fontface = "plain", size = 2.5, check_overlap = FALSE) +
  scale_fill_manual(values = brewer.pal(6,"Greens")) +
  coord_sf(xlim = lon_bounds_Bogota, ylim = lat_bounds_Bogota, datum = NA)+
  labs(title = "", fill = "Distancia cotidiana promedio per \ncápita en transporte público (km)", caption = "Autor: Hugo Thomas - Université Rennes 2 / Universidad de los Andes \nFuente: Encuesta Origen-Destino de Hogares, Secretaría Distrital de Movilidad, 2023 \nDiscretización con los cuantiles 0.10, 0.25, 0.50, 0.75, 0.90", linetype = "") +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        plot.title = element_text(size = 15, face = "bold", hjust = 0.5, vjust = 0),
        legend.title = element_text(size = 13),
        legend.text = element_text(size=13),
        plot.caption = element_text(size = 9, face = "italic", hjust = 0, vjust = 62),
        legend.text.align = 1)+
  guides(linetype = guide_legend(label.hjust = 0, order = 1))+
  labs(x = "", y = "") +
  annotation_scale(location = "br", height = unit(0.2, "cm"),text_cex = 0.8) +
  annotation_north_arrow(location = "tl", which_north = "true", height = unit(1, "cm"), width = unit(1, "cm"), style = north_arrow_orienteering(text_size = 8))
```

```{r ges}
Dist_ZAT <- viajes_dist[,c("zat_hg", "modo_principal_comparado", "CO2-eq", "fexp_vj")]%>%
  left_join(ZAT[,c("ZAT")], by = c("zat_hg" = "ZAT")) %>%
  group_by(zat_hg) %>%
  summarize(co2 = sum(fexp_vj*`CO2-eq`/1000000))

ZAT <- ZAT %>% left_join(Dist_ZAT, by = c("ZAT" = "zat_hg"))

ZAT$co2[is.na(ZAT$co2)] <- 0

UTAM_indic <- ZAT %>% 
  st_drop_geometry() %>% 
  group_by(UTAM) %>% 
  summarise(co2 = sum(co2), 
           co2_capita = 1000*sum(co2)/sum(pop))

UTAM <- UTAM %>% left_join(UTAM_indic, by = "UTAM")

LocMuni <- UTAM %>% group_by(LocMuni) %>% summarize(co2 = sum(co2))
```

```{r map ges, fig.asp=1.3, eval = FALSE}
bks_co2 <- round(as.numeric(quantile(UTAM$co2_capita, probs = c(0,0.1,0.25,0.5,0.75,0.9), na.rm = TRUE)),5)
bks <- c(bks_co2,max(UTAM$co2_capita))

UTAM$binned_co2_capita <- cut(UTAM$co2_capita,bks)

ggplot()+
  theme_bw()+
  geom_sf(data = UTAM, color = NA, aes(fill = binned_co2_capita))+
  geom_sf(data = limites_bogota, fill = NA, aes(linetype = "Límite de municipio fuera de Bogotá DC \nLímite de localidad dentro de Bogotá DC"), color = "grey")+
  geom_text(data= centroides_limites_bogota,aes(x=lon, y=lat, label = DISPLAY), color = "black", fontface = "plain", size = 2.5, check_overlap = FALSE) +
  scale_fill_manual(values = brewer.pal(6,"Oranges")) +
  coord_sf(xlim = lon_bounds_Bogota, ylim = lat_bounds_Bogota, datum = NA)+
  labs(title = "", fill = "Emisiones cotidianas promedio \nper cápita (kg CO2-eq)", caption = "Autor: Hugo Thomas - Université Rennes 2 / Universidad de los Andes \nFuente: Encuesta Origen-Destino de Hogares, Secretaría Distrital de Movilidad, 2023 \nDiscretización con los cuantiles 0.10, 0.25, 0.50, 0.75, 0.90", linetype = "") +
  theme(legend.position = "bottom",
        legend.direction = "vertical",
        plot.title = element_text(size = 15, face = "bold", hjust = 0.5, vjust = 0),
        legend.title = element_text(size = 13),
        legend.text = element_text(size=13),
        plot.caption = element_text(size = 9, face = "italic", hjust = 0, vjust = 62),
        legend.text.align = 1)+
  guides(linetype = guide_legend(label.hjust = 0, order = 1))+
  labs(x = "", y = "") +
  annotation_scale(location = "br", height = unit(0.2, "cm"),text_cex = 0.8) +
  annotation_north_arrow(location = "tl", which_north = "true", height = unit(1, "cm"), width = unit(1, "cm"), style = north_arrow_orienteering(text_size = 8))
```

## Cartography in English (map_sf)

```{r previous adaptation work}
UTAM <- UTAM %>% st_transform(32618)  
centroides_limites_bogota <- centroides_limites_bogota %>% st_transform(32618)
centroides_limites_bogota$DISPLAY <- str_to_title(centroides_limites_bogota$DISPLAY)
limites_bogota <- limites_bogota %>% st_transform(32618)

bbox <- st_bbox(c(xmin = -74.4, xmax = -73.9, ymin = 4.44, ymax = 5.04), crs = st_crs(4326)) %>% st_transform(32618)
bbox <- st_as_sfc(bbox) 

font_add("Agency FB", "C:/Windows/Fonts/AGENCYR.TTF")
showtext_auto()

font_add("Arial", "C:/Windows/Fonts/arial.TTF")
showtext_auto()

font_add("Arial Narrow", "C:/Windows/Fonts/ARIALNB.TTF")
showtext_auto()

font_add("Bahnschrift", "C:/Windows/Fonts/bahnschrift.ttf")
showtext_auto()
```

## Indicators per capita

```{r map dist capita mapsf, fig.asp = 1}
# Export
#mf_svg(x = bbox, filename = "Distancias_EODH_2023_files/figure-html/dist_bgta.svg")

mf_theme(backgroSuplllund = "white",
         highlight = "black",
         mar = c(.5,.5,.5,.5), 
         title_inner = TRUE)

# Bounding box
mf_map(bbox, col = NA, border = NA, expandBB = rep(-0.04, 4))

# Main map
mf_map(
  x = UTAM,
  var = "dist_capita",
  type = "choro",
  breaks = "quantile",
  nbreaks = 5,
  pal = "Purples",
  border = NA,
  lwd = 1,
  leg_title = "\nAverage daily distance \nper capita (km)", 
  leg_title_cex = 1.1,
  leg_val_cex = 1.1,
  leg_val_rnd = 2,
  leg_size = 1.1,
  leg_pos = "bottomleft",
  add = TRUE
)

# Borders
mf_map(
  x = limites_bogota, 
  type = "base",
  border = "grey",
  col = NA,
  lwd = 0.2,
  add = TRUE
)

# Labels
mf_label(
x = centroides_limites_bogota,
var = "DISPLAY",
col = "black",
halo = TRUE,
cex = 1,
overlap = FALSE,
lines = FALSE,
add = TRUE
)

# Layout
mf_layout(
  credits = "",
  title = "",
  arrow = FALSE,
  scale = FALSE)

mf_credits(txt = "Author: Hugo Thomas \nSource: SDM, 2023 \nDiscretization in quintiles - Package mapsf",
           col = "black",
           pos = "rightbottom",
           cex = 1)

mf_arrow(pos = "topleft",
         cex = 2)

mf_scale(size = 10, crs_units = "m", scale_units = "km", pos = "bottomright", adj = c(-20,0), cex = 1)

mf_frame(col = "black")

#dev.off()
```
```{r map walking mapsf, fig.asp = 1}
# Export
#mf_svg(x = bbox, filename = "Distancias_EODH_2023_files/figure-html/walking_bgta.svg")

mf_theme(background = "white",
         highlight = "black",
         mar = c(.5,.5,.5,.5), 
         title_inner = TRUE)

# Bounding box
mf_map(bbox, col = NA, border = NA, expandBB = rep(-0.04, 4))

# Main map
mf_map(
  x = UTAM,
  var = "walk_intensity",
  type = "choro",
  breaks = "quantile",
  nbreaks = 5,
  pal = "Reds",
  border = NA,
  lwd = 1,
  leg_title = "\nAverage daily walking \ndistance per capita (km)", 
  leg_title_cex = 1.1,
  leg_val_cex = 1.1,
  leg_val_rnd = 2,
  leg_size = 1.1,
  leg_pos = "bottomleft",
  add = TRUE
)

# Borders
mf_map(
  x = limites_bogota, 
  type = "base",
  border = "grey",
  col = NA,
  lwd = 0.2,
  add = TRUE
)

# Layout
mf_layout(
  credits = "",
  title = "",
  arrow = FALSE,
  scale = FALSE)

mf_credits(txt = "Author: Hugo Thomas \nSource: SDM, 2023 \nDiscretization in quintiles - Package mapsf",
           col = "black",
           pos = "rightbottom",
           cex = 1)

mf_arrow(pos = "topleft",
         cex = 2)

mf_scale(size = 10, crs_units = "m", scale_units = "km", pos = "bottomright", adj = c(-20,0), cex = 1)
mf_frame(col = "black")

#dev.off()
```
```{r map car mapsf, fig.asp = 1}
# Export
#mf_svg(x = bbox, filename = "Distancias_EODH_2023_files/figure-html/car_bgta.svg")

mf_theme(background = "white",
         highlight = "black",
         mar = c(.5,.5,.5,.5), 
         title_inner = TRUE)

# Bounding box
mf_map(bbox, col = NA, border = NA, expandBB = rep(-0.04, 4))

# Main map
mf_map(
  x = UTAM,
  var = "auto_intensity",
  type = "choro",
  breaks = "quantile",
  nbreaks = 5,
  pal = "RdPu",
  border = NA,
  lwd = 1,
  leg_title = "\nAverage daily distance in \nprivate car per capita (km)", 
  leg_title_cex = 1.1,
  leg_val_cex = 1.1,
  leg_val_rnd = 2,
  leg_size = 1.1,
  leg_pos = "bottomleft",
  add = TRUE
)

# Borders
mf_map(
  x = limites_bogota, 
  type = "base",
  border = "grey",
  col = NA,
  lwd = 0.2,
  add = TRUE
)

# Layout
mf_layout(
  credits = "",
  title = "",
  arrow = FALSE,
  scale = FALSE)

mf_credits(txt = "Author: Hugo Thomas \nSource: SDM, 2023 \nDiscretization in quintiles - Package mapsf",
           col = "black",
           pos = "rightbottom",
           cex = 1)

mf_arrow(pos = "topleft",
         cex = 2)

mf_scale(size = 10, crs_units = "m", scale_units = "km", pos = "bottomright", adj = c(-20,0), cex = 1)
mf_frame(col = "black")

#dev.off()
```
```{r map transit mapsf, fig.asp = 1}
# Export
#mf_svg(x = bbox, filename = "Distancias_EODH_2023_files/figure-html/transit_bgta.svg")

mf_theme(background = "white",
         highlight = "black",
         mar = c(.5,.5,.5,.5), 
         title_inner = TRUE)

# Bounding box
mf_map(bbox, col = NA, border = NA, expandBB = rep(-0.04, 4))

# Main map
mf_map(
  x = UTAM,
  var = "transit_intensity",
  type = "choro",
  breaks = "quantile",
  nbreaks = 5,
  pal = "Greens",
  border = NA,
  lwd = 1,
  leg_title = "\nAverage daily distance \nin public transport per capita (km)", 
  leg_title_cex = 1.1,
  leg_val_cex = 1.1,
  leg_val_rnd = 2,
  leg_size = 1.1,
  leg_pos = "bottomleft",
  add = TRUE
)

# Borders
mf_map(
  x = limites_bogota, 
  type = "base",
  border = "grey",
  col = NA,
  lwd = 0.2,
  add = TRUE
)

# Layout
mf_layout(
  credits = "",
  title = "",
  arrow = FALSE,
  scale = FALSE)

mf_credits(txt = "Author: Hugo Thomas \nSource: SDM, 2023 \nDiscretization in quintiles - Package mapsf",
           col = "black",
           pos = "rightbottom",
           cex = 1)

mf_arrow(pos = "topleft",
         cex = 2)

mf_scale(size = 10, crs_units = "m", scale_units = "km", pos = "bottomright", adj = c(-20,0), cex = 1)
mf_frame(col = "black")

#dev.off()
```

```{r map ges mapsf, fig.asp = 1}
LocMuni <- LocMuni %>% st_transform(32618)
UTAM <- UTAM %>% st_transform(32618)

# Export
mf_svg(x = bbox, filename = "Distancias_EODH_2023_files/figure-html/ges_bgta.svg")
#pdf(file = "Distancias_EODH_2023_files/figure-html/co2_bgta.pdf")

# Ajouter la police "Arial Narrow"
font_add("Arial Narrow", "C:/Windows/Fonts/ARIALN.TTF")
showtext_auto()
op <- par(family = "Arial Narrow")

mf_theme(background = "ivory",
         highlight = "black",
         mar = c(.5,.5,.5,.5), 
         title_inner = TRUE)

# Bounding box + shadow
mf_map(bbox, col = NA, border = NA, expandBB = rep(-0.04, 4))
mf_shadow(limites_bogota, add = TRUE) # to add a shadow
mf_map(limites_bogota, type = "base", border = NA, col = "grey95", add = TRUE)

# Main map
mf_map(
  x = UTAM,
  var = "co2_capita",
  type = "choro",
  breaks = "quantile",
  nbreaks = 5,
  pal = "Oranges",
  border = NA,
  lwd = 1,
  leg_title = "Average daily GHG emissions \nper capita (kg CO2-eq)", 
  leg_title_cex = 1.3,
  leg_val_cex = 1.1,
  leg_val_rnd = 2,
  leg_size = 1.1,
  leg_pos = "bottomleft",
  leg_bg = "white",
  leg_frame = TRUE,
  leg_frame_border = "black",
  add = TRUE
)

# Borders
mf_map(
  x = limites_bogota, 
  type = "base",
  border = "grey",
  col = NA,
  lwd = 0.2,
  add = TRUE
)

# Labels
mf_label(
x = centroides_limites_bogota,
var = "DISPLAY",
col = "black",
halo = TRUE,
cex = 0.85,
overlap = FALSE,
lines = FALSE
)

# Layout
mf_layout(
  credits = "",
  title = "",
  arrow = FALSE,
  scale = FALSE)

mf_credits(txt = "Source: SDM, 2023 - SDA, 2020 - UPME, 2015 - GHG per capita binning in quintiles - Package mapsf",
           col = "black",
           pos = "rightbottom",
           cex = 0.95,
           bg = "white"
)

mf_arrow(pos = "topleft", cex = 0.75)

mf_scale(size = 5, crs_units = "m", scale_units = "km", pos = "bottomright", adj = c(-20,0), cex = 1)
mf_frame(col = "black")

dev.off()
```


## Indicators per trip

```{r average dist per trip}
Dist_ZAT <- viajes_dist[,c("zat_hg", "modo_principal_comparado", "Distancia_incl_caminata", "fexp_vj")]%>%
  left_join(ZAT[,c("ZAT")], by = c("zat_hg" = "ZAT")) %>%
  group_by(zat_hg) %>%
  summarize(dist_2 = sum(fexp_vj*Distancia_incl_caminata/1000),
            ntrips = sum(fexp_vj))

ZAT <- ZAT %>% left_join(Dist_ZAT, by = c("ZAT" = "zat_hg"))

ZAT$dist_2[is.na(ZAT$dist_2)] <- 0
ZAT$ntrips[is.na(ZAT$ntrips)] <- 0

UTAM_indic <- ZAT %>% 
  st_drop_geometry() %>%
  group_by(UTAM) %>% 
  summarise(ntrips = sum(ntrips),
            dist_2 = sum(dist_2), 
            dist_per_trip = sum(dist_2)/sum(ntrips))



UTAM <- UTAM %>% left_join(UTAM_indic, by = "UTAM")
UTAM$ntrips_capita <- UTAM$ntrips/UTAM$pop
```


```{r average dist per trip walking}
Dist_ZAT <- viajes_dist[viajes_dist$modo_principal_comparado == "A pie",c("zat_hg", "modo_principal_comparado", "Distancia_incl_caminata", "fexp_vj")]%>%
  left_join(ZAT[,c("ZAT")], by = c("zat_hg" = "ZAT")) %>%
  group_by(zat_hg) %>%
  summarize(dist_walk_2 = sum(fexp_vj*Distancia_incl_caminata/1000),
            ntrips_walk = sum(fexp_vj))

ZAT <- ZAT %>% left_join(Dist_ZAT, by = c("ZAT" = "zat_hg"))

ZAT$dist_walk_2[is.na(ZAT$dist_walk_2)] <- 0
ZAT$ntrips_walk[is.na(ZAT$ntrips_walk)] <- 0

UTAM_indic <- ZAT %>% 
  st_drop_geometry() %>%
  group_by(UTAM) %>% 
  summarise(ntrips_walk = sum(ntrips_walk),
            dist_walk_2 = sum(dist_walk_2), 
            dist_walk_per_trip = sum(dist_walk_2)/sum(ntrips_walk))



UTAM <- UTAM %>% left_join(UTAM_indic, by = "UTAM")
UTAM$ntrips_walk_capita <- UTAM$ntrips_walk/UTAM$pop
```


```{r average dist per trip car}
Dist_ZAT <- viajes_dist[viajes_dist$modo_principal_comparado == "Auto",c("zat_hg", "modo_principal_comparado", "Distancia_incl_caminata", "fexp_vj")]%>%
  left_join(ZAT[,c("ZAT")], by = c("zat_hg" = "ZAT")) %>%
  group_by(zat_hg) %>%
  summarize(dist_auto_2 = sum(fexp_vj*Distancia_incl_caminata/1000),
            ntrips_auto = sum(fexp_vj))

ZAT <- ZAT %>% left_join(Dist_ZAT, by = c("ZAT" = "zat_hg"))

ZAT$dist_auto_2[is.na(ZAT$dist_auto_2)] <- 0
ZAT$ntrips_auto[is.na(ZAT$ntrips_auto)] <- 0

UTAM_indic <- ZAT %>% 
  st_drop_geometry() %>%
  group_by(UTAM) %>% 
  summarise(ntrips_auto = sum(ntrips_auto),
            dist_auto_2 = sum(dist_auto_2), 
            dist_auto_per_trip = sum(dist_auto_2)/sum(ntrips_auto))



UTAM <- UTAM %>% left_join(UTAM_indic, by = "UTAM")

UTAM$ntrips_auto_capita <- UTAM$ntrips_auto/UTAM$pop
```


```{r average dist per trip transit}
Dist_ZAT <- viajes_dist[viajes_dist$modo_principal_comparado == "Transporte publico",c("zat_hg", "modo_principal_comparado", "Distancia_incl_caminata", "fexp_vj")]%>%
  left_join(ZAT[,c("ZAT")], by = c("zat_hg" = "ZAT")) %>%
  group_by(zat_hg) %>%
  summarize(dist_transit_2 = sum(fexp_vj*Distancia_incl_caminata/1000),
            ntrips_transit = sum(fexp_vj))

ZAT <- ZAT %>% left_join(Dist_ZAT, by = c("ZAT" = "zat_hg"))

ZAT$dist_transit_2[is.na(ZAT$dist_transit_2)] <- 0
ZAT$ntrips_transit[is.na(ZAT$ntrips_transit)] <- 0

UTAM_indic <- ZAT %>% 
  st_drop_geometry() %>%
  group_by(UTAM) %>% 
  summarise(ntrips_transit = sum(ntrips_transit),
            dist_transit_2 = sum(dist_transit_2), 
            dist_transit_per_trip = sum(dist_transit_2)/sum(ntrips_transit))



UTAM <- UTAM %>% left_join(UTAM_indic, by = "UTAM")

UTAM$ntrips_transit_capita <- UTAM$ntrips_transit/UTAM$pop
```


# Bivariate maps

```{r thresholds}
thresholds <- data.frame(ntrips_walk_capita = median(UTAM$ntrips_walk_capita),
                         ntrips_auto_capita = median(UTAM$ntrips_auto_capita),
                         ntrips_transit_capita = median(UTAM$ntrips_transit_capita),
                         dist_walk_per_trip = median(UTAM$dist_walk_per_trip),
                         dist_auto_per_trip = median(UTAM$dist_auto_per_trip),
                         dist_transit_per_trip = median(UTAM$dist_transit_per_trip))

#Walking
UTAM$typo_walk[UTAM$ntrips_walk_capita <= median(UTAM$ntrips_walk_capita) & UTAM$dist_walk_per_trip <= median(UTAM$dist_walk_per_trip)] <- "A few short trips"
UTAM$typo_walk[UTAM$ntrips_walk_capita <= median(UTAM$ntrips_walk_capita) & UTAM$dist_walk_per_trip > median(UTAM$dist_walk_per_trip)] <- "A few long trips"
UTAM$typo_walk[UTAM$ntrips_walk_capita > median(UTAM$ntrips_walk_capita) & UTAM$dist_walk_per_trip <= median(UTAM$dist_walk_per_trip)] <- "Many short trips"
UTAM$typo_walk[UTAM$ntrips_walk_capita > median(UTAM$ntrips_walk_capita) & UTAM$dist_walk_per_trip > median(UTAM$dist_walk_per_trip)] <- "Many long trips"

#Car
UTAM$typo_auto[UTAM$ntrips_auto_capita <= median(UTAM$ntrips_auto_capita) & UTAM$dist_auto_per_trip <= median(UTAM$dist_auto_per_trip)] <- "A few short trips"
UTAM$typo_auto[UTAM$ntrips_auto_capita <= median(UTAM$ntrips_auto_capita) & UTAM$dist_auto_per_trip > median(UTAM$dist_auto_per_trip)] <- "A few long trips"
UTAM$typo_auto[UTAM$ntrips_auto_capita > median(UTAM$ntrips_auto_capita) & UTAM$dist_auto_per_trip <= median(UTAM$dist_auto_per_trip)] <- "Many short trips"
UTAM$typo_auto[UTAM$ntrips_auto_capita > median(UTAM$ntrips_auto_capita) & UTAM$dist_auto_per_trip > median(UTAM$dist_auto_per_trip)] <- "Many long trips"

#Transit
UTAM$typo_transit[UTAM$ntrips_transit_capita <= median(UTAM$ntrips_transit_capita) & UTAM$dist_transit_per_trip <= median(UTAM$dist_transit_per_trip)] <- "A few short trips"
UTAM$typo_transit[UTAM$ntrips_transit_capita <= median(UTAM$ntrips_transit_capita) & UTAM$dist_transit_per_trip > median(UTAM$dist_transit_per_trip)] <- "A few long trips"
UTAM$typo_transit[UTAM$ntrips_transit_capita > median(UTAM$ntrips_transit_capita) & UTAM$dist_transit_per_trip <= median(UTAM$dist_transit_per_trip)] <- "Many short trips"
UTAM$typo_transit[UTAM$ntrips_transit_capita > median(UTAM$ntrips_transit_capita) & UTAM$dist_transit_per_trip > median(UTAM$dist_transit_per_trip)] <- "Many long trips"

#Set to factors
UTAM <- UTAM %>% mutate(across(c("typo_walk", "typo_auto", "typo_transit"), factor, levels=c("A few short trips","A few long trips","Many short trips","Many long trips")))

# to convert from number of trips per capita to number of trips per 1000 hab

UTAM$ntrips_walk_1000_hab <- 1000*UTAM$ntrips_walk_capita
UTAM$ntrips_auto_1000_hab <- 1000*UTAM$ntrips_auto_capita
UTAM$ntrips_transit_1000_hab <- 1000*UTAM$ntrips_transit_capita


# to coerce values to factor
UTAM$typo_walk <- as.factor(UTAM$typo_walk)
UTAM$typo_auto <- as.factor(UTAM$typo_auto)
UTAM$typo_transit <- as.factor(UTAM$typo_transit)

# to reorder factors
UTAM$typo_walk <- factor(
  UTAM$typo_walk,
  levels = c(
    "A few short trips",
    "A few long trips",
    "Many short trips",
    "Many long trips"
  )
)

UTAM$typo_auto <- factor(
  UTAM$typo_auto,
  levels = c(
    "A few short trips",
    "A few long trips",
    "Many short trips",
    "Many long trips"
  )
)

UTAM$typo_transit <- factor(
  UTAM$typo_transit,
  levels = c(
    "A few short trips",
    "A few long trips",
    "Many short trips",
    "Many long trips"
  )
)

# to change the names of the factors
levels(UTAM$typo_walk) <- c(
  "Fewer trips per 1000 inhab. and shorter distances",
  "Fewer trips per 1000 inhab. and longer distances",
  "More trips per 1000 inhab. and shorter distances",
  "More trips per 1000 inhab. and longer distances"
)

levels(UTAM$typo_auto) <- c(
  "Fewer trips per 1000 inhab. and shorter distances",
  "Fewer trips per 1000 inhab. and longer distances",
  "More trips per 1000 inhab. and shorter distances",
  "More trips per 1000 inhab. and longer distances"
)

levels(UTAM$typo_transit) <- c(
  "Fewer trips per 1000 inhab. and shorter distances",
  "Fewer trips per 1000 inhab. and longer distances",
  "More trips per 1000 inhab. and shorter distances",
  "More trips per 1000 inhab. and longer distances"
)
```

```{r typo walking mapsf}
# Export
mf_svg(x = bbox, filename = "Distancias_EODH_2023_files/figure-html/typo_walking_bogota.svg")
#pdf(file = "Distancias_EODH_2023_files/figure-html/typo_walking_bogota.pdf")

# Ajouter la police "Arial Narrow"
font_add("Arial Narrow", "C:/Windows/Fonts/ARIALN.TTF")
showtext_auto()
op <- par(family = "Arial Narrow")

mf_theme(background = "ivory",
         highlight = "black",
         mar = c(.5,.5,.5,.5), 
         title_inner = TRUE)

# Bounding box + shadow
mf_map(bbox, col = NA, border = NA, expandBB = rep(-0.04, 4))
mf_shadow(limites_bogota, add = TRUE) # to add a shadow
mf_map(limites_bogota, type = "base", border = NA, col = "grey95", add = TRUE)

# Main map
mf_map(
  x = UTAM,
  var = "typo_walk",
  pal = c("#FFE2E2", "#FF6467", "#ECFCCA", "#9AE630"),
  type = "typo",
  border = NA,
  lwd = 1,
  leg_title = "Walking intensity", 
  leg_title_cex = 1.3,
  leg_val_cex = 1.1,
  leg_size = 1.1,
  leg_pos = "bottomleft",
  leg_bg = "white",
  leg_frame = TRUE,
  leg_frame_border = "black",
  add = TRUE
)

# Borders
mf_map(
  x = limites_bogota, 
  type = "base",
  border = "grey",
  col = NA,
  lwd = 0.2,
  add = TRUE
)

# Labels
mf_label(
x = centroides_limites_bogota,
var = "DISPLAY",
col = "black",
halo = TRUE,
cex = 0.85,
overlap = FALSE,
lines = FALSE
)

# Layout
mf_layout(
  credits = "",
  title = "",
  arrow = FALSE,
  scale = FALSE)

mf_credits(txt = "Source: SDM, 2023. Typology based on median values - Packages ggplot 2 / mapsf",
           col = "black",
           pos = "rightbottom",
           cex = 0.95,
           bg = "white"
)

mf_arrow(pos = "topleft", cex = 0.75)

mf_scale(size = 5, crs_units = "m", scale_units = "km", pos = "bottomright", adj = c(-20,0), cex = 1)

# définition de la taille de l'encart, dans l'unité de la fenêtre graphique (ndc)
x1 <- 0.10
x2 <- 0.52
y1 <- 0.72
y2 <- 0.97


# --- Construction du scatter (ggplot) ---

df <- st_drop_geometry(UTAM)

med_x <- median(df$dist_walk_per_trip, na.rm = TRUE)
med_y <- median(df$ntrips_walk_1000_hab, na.rm = TRUE)

quadrants <- data.frame(
  xmin = c(min(df$dist_walk_per_trip), med_x, min(df$dist_walk_per_trip), med_x),
  xmax = c(med_x, max(df$dist_walk_per_trip), med_x, max(df$dist_walk_per_trip)),
  ymin = c(min(df$ntrips_walk_1000_hab), min(df$ntrips_walk_1000_hab), med_y, med_y),
  ymax = c(med_y, med_y, max(df$ntrips_walk_1000_hab), max(df$ntrips_walk_1000_hab)),
  fill = c("Q1", "Q2", "Q3", "Q4")
)

quad_cols <- c(
  "Q1" = "#FFE2E2",
  "Q2" = "#FF6467",
  "Q3" = "#ECFCCA",
  "Q4" = "#9AE630"
)

legende <- ggplot() +
  geom_rect(
    data = quadrants,
    aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = fill),
    alpha = 1
  ) +
  geom_point(
    data = df,
    aes(x = dist_walk_per_trip, y = ntrips_walk_1000_hab),
    color = "black", size = 0.5
  ) +
  geom_vline(xintercept = med_x, linetype = "dashed") +
  geom_hline(yintercept = med_y, linetype = "dashed") +
  scale_fill_manual(values = quad_cols, guide = "none") +
  labs(x = "Dist. per trip", y = "Trips per 1000 inhabitants") +
  theme_minimal() +
  theme(
    text = element_text(family = "Arial Narrow"),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background  = element_rect(fill = "white", color = "black", linewidth = 0.4)
  )

# 1. Paramètres de l’encart (NDC : entre 0 et 1)
vp <- viewport(
  x = x1 + (x2 - x1)/2,   # centre en x
  y = y1 + (y2 - y1)/2,   # centre en y
  width  = x2 - x1,       # largeur
  height = y2 - y1        # hauteur
)

# 2. Capture du graphique ggplot comme objet grid
legende <- grid.grabExpr(print(legende))

# 3. Activation du nouvel espace graphique de l'encart
par(fig = c(x1, x2, y1, y2),
    mar = c(0, 0, 0, 0),
    new = TRUE)

# 4. Dessin du ggplot DANS le viewport
pushViewport(vp)
grid.draw(legende)
popViewport()

# Revenir à la figure pleine
par(fig = c(0, 1, 0, 1), new = FALSE)

mf_frame(col = "black")

par(op)

dev.off()
```
```{r typo car mapsf}
# Export
mf_svg(x = bbox, filename = "Distancias_EODH_2023_files/figure-html/typo_car_bogota.svg")
#pdf(file = "Distancias_EODH_2023_files/figure-html/typo_car_bogota.pdf")

# Ajouter la police "Arial Narrow"
font_add("Arial Narrow", "C:/Windows/Fonts/ARIALN.TTF")
showtext_auto()
op <- par(family = "Arial Narrow")

mf_theme(background = "ivory",
         highlight = "black",
         mar = c(.5,.5,.5,.5), 
         title_inner = TRUE)

# Bounding box + shadow
mf_map(bbox, col = NA, border = NA, expandBB = rep(-0.04, 4))
mf_shadow(limites_bogota, add = TRUE) # to add a shadow
mf_map(limites_bogota, type = "base", border = NA, col = "grey95", add = TRUE)

# Main map
mf_map(
  x = UTAM,
  var = "typo_auto",
  pal = c("#FFE2E2", "#FF6467", "#ECFCCA", "#9AE630"),
  type = "typo",
  border = NA,
  lwd = 1,
  leg_title = "Private car intensity", 
  leg_title_cex = 1.3,
  leg_val_cex = 1.1,
  leg_size = 1.1,
  leg_pos = "bottomleft",
  leg_bg = "white",
  leg_frame = TRUE,
  leg_frame_border = "black",
  add = TRUE
)

# Borders
mf_map(
  x = limites_bogota, 
  type = "base",
  border = "grey",
  col = NA,
  lwd = 0.2,
  add = TRUE
)

# Labels
mf_label(
x = centroides_limites_bogota,
var = "DISPLAY",
col = "black",
halo = TRUE,
cex = 0.85,
overlap = FALSE,
lines = FALSE
)

# Layout
mf_layout(
  credits = "",
  title = "",
  arrow = FALSE,
  scale = FALSE)

mf_credits(txt = "Source: SDM, 2023. Typology based on median values - Packages ggplot 2 / mapsf",
           col = "black",
           pos = "rightbottom",
           cex = 0.95,
           bg = "white"
)

mf_arrow(pos = "topleft", cex = 0.75)

mf_scale(size = 5, crs_units = "m", scale_units = "km", pos = "bottomright", adj = c(-20,0), cex = 1)

# définition de la taille de l'encart, dans l'unité de la fenêtre graphique (ndc)
x1 <- 0.10
x2 <- 0.52
y1 <- 0.72
y2 <- 0.97


# --- Construction du scatter (ggplot) ---

df <- st_drop_geometry(UTAM)

med_x <- median(df$dist_auto_per_trip, na.rm = TRUE)
med_y <- median(df$ntrips_auto_1000_hab, na.rm = TRUE)

quadrants <- data.frame(
  xmin = c(min(df$dist_auto_per_trip), med_x, min(df$dist_auto_per_trip), med_x),
  xmax = c(med_x, max(df$dist_auto_per_trip), med_x, max(df$dist_auto_per_trip)),
  ymin = c(min(df$ntrips_auto_1000_hab), min(df$ntrips_auto_1000_hab), med_y, med_y),
  ymax = c(med_y, med_y, max(df$ntrips_auto_1000_hab), max(df$ntrips_auto_1000_hab)),
  fill = c("Q1", "Q2", "Q3", "Q4")
)

quad_cols <- c(
  "Q1" = "#FFE2E2",
  "Q2" = "#FF6467",
  "Q3" = "#ECFCCA",
  "Q4" = "#9AE630"
)

legende <- ggplot() +
  geom_rect(
    data = quadrants,
    aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = fill),
    alpha = 1
  ) +
  geom_point(
    data = df,
    aes(x = dist_auto_per_trip, y = ntrips_auto_1000_hab),
    color = "black", size = 0.5
  ) +
  geom_vline(xintercept = med_x, linetype = "dashed") +
  geom_hline(yintercept = med_y, linetype = "dashed") +
  scale_fill_manual(values = quad_cols, guide = "none") +
  labs(x = "Dist. per trip", y = "Trips per 1000 inhabitants") +
  theme_minimal() +
  theme(
    text = element_text(family = "Arial Narrow"),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background  = element_rect(fill = "white", color = "black", linewidth = 0.4)
  )

# 1. Paramètres de l’encart (NDC : entre 0 et 1)
vp <- viewport(
  x = x1 + (x2 - x1)/2,   # centre en x
  y = y1 + (y2 - y1)/2,   # centre en y
  width  = x2 - x1,       # largeur
  height = y2 - y1        # hauteur
)

# 2. Capture du graphique ggplot comme objet grid
legende <- grid.grabExpr(print(legende))

# 3. Activation du nouvel espace graphique de l'encart
par(fig = c(x1, x2, y1, y2),
    mar = c(0, 0, 0, 0),
    new = TRUE)

# 4. Dessin du ggplot DANS le viewport
pushViewport(vp)
grid.draw(legende)
popViewport()

# Revenir à la figure pleine
par(fig = c(0, 1, 0, 1), new = FALSE)

mf_frame(col = "black")

par(op)

dev.off()
```
```{r typo transit mapsf}
# Export
mf_svg(x = bbox, filename = "Distancias_EODH_2023_files/figure-html/typo_transit_bogota.svg")
#pdf(file = "Distancias_EODH_2023_files/figure-html/typo_transit_bogota.pdf")

# Ajouter la police "Arial Narrow"
font_add("Arial Narrow", "C:/Windows/Fonts/ARIALN.TTF")
showtext_auto()
op <- par(family = "Arial Narrow")

mf_theme(background = "ivory",
         highlight = "black",
         mar = c(.5,.5,.5,.5), 
         title_inner = TRUE)

# Bounding box + shadow
mf_map(bbox, col = NA, border = NA, expandBB = rep(-0.04, 4))
mf_shadow(limites_bogota, add = TRUE) # to add a shadow
mf_map(limites_bogota, type = "base", border = NA, col = "grey95", add = TRUE)

# Main map
mf_map(
  x = UTAM,
  var = "typo_transit",
  pal = c("#FFE2E2", "#FF6467", "#ECFCCA", "#9AE630"),
  type = "typo",
  border = NA,
  lwd = 1,
  leg_title = "Public transport intensity", 
  leg_title_cex = 1.3,
  leg_val_cex = 1.1,
  leg_size = 1.1,
  leg_pos = "bottomleft",
  leg_bg = "white",
  leg_frame = TRUE,
  leg_frame_border = "black",
  add = TRUE
)

# Borders
mf_map(
  x = limites_bogota, 
  type = "base",
  border = "grey",
  col = NA,
  lwd = 0.2,
  add = TRUE
)

# Labels
mf_label(
x = centroides_limites_bogota,
var = "DISPLAY",
col = "black",
halo = TRUE,
cex = 0.85,
overlap = FALSE,
lines = FALSE
)

# Layout
mf_layout(
  credits = "",
  title = "",
  arrow = FALSE,
  scale = FALSE)

mf_credits(txt = "Source: SDM, 2023. Typology based on median values - Packages ggplot 2 / mapsf",
           col = "black",
           pos = "rightbottom",
           cex = 0.95,
           bg = "white"
)

mf_arrow(pos = "topleft", cex = 0.75)

mf_scale(size = 5, crs_units = "m", scale_units = "km", pos = "bottomright", adj = c(-20,0), cex = 1)

# définition de la taille de l'encart, dans l'unité de la fenêtre graphique (ndc)
x1 <- 0.10
x2 <- 0.52
y1 <- 0.72
y2 <- 0.97


# --- Construction du scatter (ggplot) ---

df <- st_drop_geometry(UTAM)

med_x <- median(df$dist_transit_per_trip, na.rm = TRUE)
med_y <- median(df$ntrips_transit_1000_hab, na.rm = TRUE)

quadrants <- data.frame(
  xmin = c(min(df$dist_transit_per_trip), med_x, min(df$dist_transit_per_trip), med_x),
  xmax = c(med_x, max(df$dist_transit_per_trip), med_x, max(df$dist_transit_per_trip)),
  ymin = c(min(df$ntrips_transit_1000_hab), min(df$ntrips_transit_1000_hab), med_y, med_y),
  ymax = c(med_y, med_y, max(df$ntrips_transit_1000_hab), max(df$ntrips_transit_1000_hab)),
  fill = c("Q1", "Q2", "Q3", "Q4")
)

quad_cols <- c(
  "Q1" = "#FFE2E2",
  "Q2" = "#FF6467",
  "Q3" = "#ECFCCA",
  "Q4" = "#9AE630"
)

legende <- ggplot() +
  geom_rect(
    data = quadrants,
    aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax, fill = fill),
    alpha = 1
  ) +
  geom_point(
    data = df,
    aes(x = dist_transit_per_trip, y = ntrips_transit_1000_hab),
    color = "black", size = 0.5
  ) +
  geom_vline(xintercept = med_x, linetype = "dashed") +
  geom_hline(yintercept = med_y, linetype = "dashed") +
  scale_fill_manual(values = quad_cols, guide = "none") +
  labs(x = "Dist. per trip", y = "Trips per 1000 inhabitants") +
  theme_minimal() +
  theme(
    text = element_text(family = "Arial Narrow"),
    panel.background = element_rect(fill = "white", color = NA),
    plot.background  = element_rect(fill = "white", color = "black", linewidth = 0.4)
  )

# 1. Paramètres de l’encart (NDC : entre 0 et 1)
vp <- viewport(
  x = x1 + (x2 - x1)/2,   # centre en x
  y = y1 + (y2 - y1)/2,   # centre en y
  width  = x2 - x1,       # largeur
  height = y2 - y1        # hauteur
)

# 2. Capture du graphique ggplot comme objet grid
legende <- grid.grabExpr(print(legende))

# 3. Activation du nouvel espace graphique de l'encart
par(fig = c(x1, x2, y1, y2),
    mar = c(0, 0, 0, 0),
    new = TRUE)

# 4. Dessin du ggplot DANS le viewport
pushViewport(vp)
grid.draw(legende)
popViewport()

# Revenir à la figure pleine
par(fig = c(0, 1, 0, 1), new = FALSE)

mf_frame(col = "black")

par(op)

dev.off()
```


# Correlaciones

```{r update utam}
UTAM$ntrips_capita <- UTAM$ntrips/UTAM$pop
UTAM$ntrips_auto_capita <- UTAM$ntrips_auto/UTAM$pop
UTAM$ntrips_walk_capita <- UTAM$ntrips_walk/UTAM$pop
UTAM$ntrips_transit_capita <- UTAM$ntrips_transit/UTAM$pop
```

```{r correlaciones}
UTAM_ICS <- read.xlsx("UTAM_ICS.xlsx")
UTAM <- UTAM %>% left_join(UTAM_ICS, by = "UTAM")

correlaciones <- rbind(data.frame(cor.test(UTAM$propICS12, UTAM$auto_intensity, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$propICS12, UTAM$walk_intensity, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$propICS12, UTAM$transit_intensity, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$co2_capita, UTAM$auto_intensity, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$propICS12, UTAM$co2_capita, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$dist_auto_per_trip, UTAM$co2_capita, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$dist_walk_per_trip, UTAM$co2_capita, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$dist_transit_per_trip, UTAM$co2_capita, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$dist_auto_per_trip, UTAM$propICS12, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$dist_walk_per_trip, UTAM$propICS12, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$dist_transit_per_trip, UTAM$propICS12, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$dist_per_trip, UTAM$propICS12, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$dist_capita, UTAM$propICS12, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$ntrips/UTAM$pop, UTAM$propICS12, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$ntrips_auto/UTAM$pop, UTAM$propICS12, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$ntrips_walk/UTAM$pop, UTAM$propICS12, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$ntrips_transit/UTAM$pop, UTAM$propICS12, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$ntrips/UTAM$pop, UTAM$co2_capita, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$ntrips_auto/UTAM$pop, UTAM$co2_capita, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$ntrips_walk/UTAM$pop, UTAM$co2_capita, method = "pearson")[c(4,3)]),
              data.frame(cor.test(UTAM$ntrips_transit/UTAM$pop, UTAM$co2_capita, method = "pearson")[c(4,3)]))

rownames(correlaciones) <- c("ICS_dist_auto_capita",
                             "ICS_dist_walk_capita",
                             "ICS_dist_transit_capita",
                             "GES_dist_auto_capita",
                             "ICS_GES_capita",
                             "GES_dist_auto_trip",
                             "GES_dist_walk_trip",
                             "GES_dist_transit_trip",
                             "ICS_dist_auto_trip",
                             "ICS_dist_walk_trip",
                             "ICS_dist_transit_trip",
                             "dist_trip_total_ICS",
                             "dist_capita_total_ICS",
                             "ntrips_per_capita_ICS",
                             "ntrips_per_capita_auto_ICS",
                             "ntrips_per_capita_walk_ICS",
                             "ntrips_per_capita_transit_ICS",
                             "ntrips_per_capita_GES",
                             "ntrips_per_capita_auto_GES",
                             "ntrips_per_capita_walk_GES",
                             "ntrips_per_capita_transit_GES")

kable(correlaciones, caption = "Correlaciones", format.args = list(big.mark = ","))

correlaciones <- cbind(rownames(correlaciones), correlaciones)

#write.xlsx(correlaciones, "correlaciones.xlsx", overwrite = TRUE)
```

# Palma ratio

```{r palma, eval = TRUE}
UTAM_top_10 <- UTAM[order(UTAM$propICS12, decreasing = FALSE),]
select <-as.integer(0.1*nrow(UTAM_top_10))
UTAM_top_10 <- UTAM_top_10[1:select,]

UTAM_bottom_40 <- UTAM[order(UTAM$propICS12, decreasing = TRUE),]
select <-as.integer(0.4*nrow(UTAM_bottom_40))
UTAM_bottom_40 <- UTAM_bottom_40[1:select,]

palma <- rbind(data.frame(top_10 = weighted.mean(x = UTAM_top_10$dist_capita, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$dist_capita, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$auto_intensity, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$auto_intensity, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$walk_intensity, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$walk_intensity, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$transit_intensity, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$transit_intensity, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$co2_capita, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$co2_capita, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$dist_per_trip, w = UTAM_top_10$ntrips),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$dist_per_trip, w = UTAM_bottom_40$ntrips)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$dist_auto_per_trip, w = UTAM_top_10$ntrips_auto),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$dist_auto_per_trip, w = UTAM_bottom_40$ntrips_auto)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$dist_walk_per_trip, w = UTAM_top_10$ntrips_walk),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$dist_walk_per_trip, w = UTAM_bottom_40$ntrips_walk)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$dist_transit_per_trip, w = UTAM_top_10$ntrips_transit),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$dist_transit_per_trip, w = UTAM_bottom_40$ntrips_transit)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$co2, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$co2, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$ntrips, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$ntrips, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$ntrips_auto, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$ntrips_auto, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$ntrips_walk, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$ntrips_walk, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$ntrips_transit, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$ntrips_transit, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$dist, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$dist, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$dist_auto, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$dist_auto, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$dist_walk, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$dist_walk, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$dist_transit, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$dist_transit, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$ntrips_capita, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$ntrips_capita, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$ntrips_auto_capita, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$ntrips_auto_capita, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$ntrips_walk_capita, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$ntrips_walk_capita, w = UTAM_bottom_40$pop)),
               data.frame(top_10 = weighted.mean(x = UTAM_top_10$ntrips_transit_capita, w = UTAM_top_10$pop),
                   bottom_40 = weighted.mean(x = UTAM_bottom_40$ntrips_transit_capita, w = UTAM_bottom_40$pop)))


palma$palma <- palma$top_10/palma$bottom_40

rownames(palma) <- c("dist_capita",
                     "auto_intensity",
                     "walk_intensity",
                     "transit_intensity",
                     "co2_capita",
                     "dist_trip",
                     "dist_auto_trip",
                     "dist_walk_trip",
                     "dist_transit_trip",
                     "co2_total",
                     "ntrips_total",
                     "ntrips_auto",
                     "ntrips_walk",
                     "ntrips_transit",
                     "PKT_total",
                     "PKT_auto",
                     "PKT_walk",
                     "PKT_transit",
                     "ntrips_per_capita",
                     "ntrips_auto_per_capita",
                     "ntrips_walk_per_capita",
                     "ntrips_transit_per_capita")

kable(palma, caption = "Palma ratios", format.args = list(big.mark = ","))

palma <- cbind(rownames(palma), palma)

#write.xlsx(palma, "palma.xlsx", overwrite = TRUE)
```

# Valores promediados de los indicadores

```{r promedios}
promedios <- data.frame(dist_capita = sum(UTAM$dist)/sum(UTAM$pop),
                        walk_intensity = sum(UTAM$dist_walk)/sum(UTAM$pop),
                        auto_intensity = sum(UTAM$dist_auto)/sum(UTAM$pop),
                        transit_intensity = sum(UTAM$dist_transit)/sum(UTAM$pop),
                        ges_capita = 1000*sum(UTAM$co2)/sum(UTAM$pop))

kable(promedios, caption = "Valores promediados de los indicadores", format.args = list(big.mark = ","))

#write.xlsx(promedios, "promedios.xlsx", overwrite = TRUE)
```

# Posesión de vehículos

```{r vehículos}
setwd("C:/Users/hugot/Documents/Uniandes/EODH2023/EODH 2023 oficial/Publicacion1804/EODH/02_Base datos procesada/XLSX")
Vehiculos <- read.xlsx("b. Modulo vehiculos.xlsx")

auto_hog <- Vehiculos[Vehiculos$tipo_vehículo == "Automóvil",] %>% group_by(cod_hog) %>% summarise(num_auto = sum(cantidad))
moto_hog <- Vehiculos[Vehiculos$tipo_vehículo == "Motocicleta",] %>% group_by(cod_hog) %>% summarise(num_moto = sum(cantidad))
bici_hog <- Vehiculos[Vehiculos$tipo_vehículo %in% c("Bicicleta sin motor", "Bicicleta niños"),] %>% group_by(cod_hog) %>% summarise(num_bici = sum(cantidad))

Hogares <- Hogares %>% 
  left_join(auto_hog, by = "cod_hog") %>%
  left_join(moto_hog, by = "cod_hog") %>%
  left_join(bici_hog, by = "cod_hog")

Hogares$num_auto[is.na(Hogares$num_auto)] <- 0
Hogares$num_moto[is.na(Hogares$num_moto)] <- 0
Hogares$num_bici[is.na(Hogares$num_bici)] <- 0

poblacion_localidad <- Personas %>% 
  left_join(Hogares[,c("cod_hog", "nom_loc_hg")], by = c("cod_hg" = "cod_hog")) %>%
  group_by(nom_loc_hg) %>%
  summarize(poblacion = sum(`fexp_per>5años`))

vehiculos <- Hogares[,c("cod_hog", "nom_loc_hg", "num_bici", "num_moto", "num_auto", "fexp_hg", "perstotal_hg")] %>%
  group_by(nom_loc_hg) %>%
  summarise(num_bici = sum(fexp_hg*num_bici), 
            num_moto = sum(fexp_hg*num_moto), 
            num_auto = sum(fexp_hg*num_auto))%>%
  left_join(poblacion_localidad, by = "nom_loc_hg")%>%
  st_drop_geometry()

vehiculos_total <- data.frame(nom_loc_hg = "TOTAL",
                              num_bici = sum(vehiculos$num_bici),
                              num_moto = sum(vehiculos$num_moto),
                              num_auto = sum(vehiculos$num_auto),
                              poblacion = sum(vehiculos$poblacion))

vehiculos <- rbind(vehiculos, vehiculos_total)

vehiculos$auto_1000_hab = 1000*vehiculos$num_auto/vehiculos$poblacion
vehiculos$moto_1000_hab = 1000*vehiculos$num_moto/vehiculos$poblacion
vehiculos$bici_1000_hab = 1000*vehiculos$num_bici/vehiculos$poblacion

kable(vehiculos, caption = "Número de vehículos por distrito y tasa de posesión por 1000 hab", format.args = list(big.mark = ","), digits = 0)

#write.xlsx(vehiculos, "vehiculos.xlsx")
```

# Map ICS

```{r map ICS mapsf, fig.asp = 1}
# Export
mf_svg(x = bbox, filename = "Distancias_EODH_2023_files/figure-html/Bogota_ICS.svg")
#pdf(file = "Distancias_EODH_2023_files/figure-html/Bogota_ICS.pdf")

# Ajouter la police "Arial Narrow"
font_add("Arial Narrow", "C:/Windows/Fonts/ARIALN.TTF")
showtext_auto()
op <- par(family = "Arial Narrow")

mf_theme(background = "ivory",
         highlight = "black",
         mar = c(.5,.5,.5,.5), 
         title_inner = TRUE)

# Bounding box + shadow
mf_map(bbox, col = NA, border = NA, expandBB = rep(-0.04, 4))
mf_shadow(limites_bogota, add = TRUE) # to add a shadow
mf_map(limites_bogota, type = "base", border = NA, col = "grey95", add = TRUE)

# Main map
mf_map(
  x = UTAM,
  var = "propICS12",
  type = "choro",
  breaks = "quantile",
  nbreaks = 5,
  pal = "Reds",
  border = NA,
  lwd = 1,
  leg_title = "\n% low-ICS \nhouseholds", 
  leg_title_cex = 1.3,
  leg_val_cex = 1.1,
  leg_val_rnd = 2,
  leg_size = 1.1,
  leg_pos = "bottomleft",
  add = TRUE
)


# Borders
mf_map(
  x = limites_bogota, 
  type = "base",
  border = "grey",
  col = NA,
  lwd = 0.2,
  add = TRUE
)

# Labels
mf_label(
x = centroides_limites_bogota,
var = "DISPLAY",
col = "black",
halo = TRUE,
cex = 0.85,
overlap = FALSE,
lines = FALSE
)

# Layout
mf_layout(
  credits = "",
  title = "",
  arrow = FALSE,
  scale = FALSE)

mf_credits(txt = "Source: DANE, 2018 - Package mapsf",
           col = "black",
           pos = "rightbottom",
           cex = 0.95,
           bg = "white"
)

mf_arrow(pos = "topleft", cex = 0.95)

mf_scale(size = 5, crs_units = "m", scale_units = "km", pos = "bottomright", adj = c(-20,0), cex = 1)
mf_frame(col = "black")

dev.off()
```

# Map Public Transport

```{r more work on data}
Transmi <- Transmi %>% st_transform(32618)
SITP <- st_read(dsn = ".", layer = "Rutas_Zonales_SITP") %>% st_transform(32618)
Cable <- st_read(dsn = ".", layer = "Transmicable") %>% st_transform(32618)
```

```{r map public transport network mapsf, fig.asp = 1}
# Export
mf_svg(x = bbox, filename = "Distancias_EODH_2023_files/figure-html/Bogota_TC.svg")
#pdf(file = "Distancias_EODH_2023_files/figure-html/Bogota_TC.pdf")

# Ajouter la police "Arial Narrow"
font_add("Arial Narrow", "C:/Windows/Fonts/ARIALN.TTF")
showtext_auto()
op <- par(family = "Arial Narrow")

mf_theme(background = "ivory",
         highlight = "black",
         mar = c(.5,.5,.5,.5), 
         title_inner = TRUE)

# Bounding box + shadow
mf_map(bbox, col = NA, border = NA, expandBB = rep(-0.04, 4))
mf_shadow(limites_bogota, add = TRUE) # to add a shadow
mf_map(limites_bogota, type = "base", border = NA, col = "grey95", add = TRUE)

# Urban area
mf_map(
  x = UTAM, 
  type = "base",
  border = NA,
  col = "grey80",
  lwd = 0.2,
  add = TRUE
)

# Borders
mf_map(
  x = limites_bogota, 
  type = "base",
  border = "grey",
  col = NA,
  lwd = 0.2,
  add = TRUE
)

# SITP
mf_map(
  x = SITP, 
  type = "base",
  col = "darkorange",
  lwd = 0.2,
  leg_title = "SITP",
  add = TRUE
)

# Transmilenio
mf_map(
  x = Transmi, 
  type = "base",
  col = "brown1",
  lwd = 2,
  add = TRUE
)

# Transmicable
mf_map(
  x = Cable, 
  type = "base",
  col = "brown4",
  lwd = 2,
  add = TRUE
)

# Labels
mf_label(
x = centroides_limites_bogota,
var = "DISPLAY",
col = "black",
halo = TRUE,
cex = 0.85,
overlap = FALSE,
lines = FALSE,
add = TRUE
)

#Legend

linewidth = c(4,4)

mf_legend(
  type = "grad_line",
  val = c("", "\nBRT"),
  col = "brown1",
  lwd = linewidth,
  title = NA, 
  val_cex = 1.1,
  size = 1.1,
  pos = "bottomleft",
  adj = c(0,9)
)

mf_legend(
  type = "grad_line",
  val = c("", "\nLocal bus"),
  col = "darkorange",
  lwd = linewidth,
  title = NA, 
  val_cex = 1.1,
  size = 1.1,
  pos = "bottomleft",
  adj = c(0,6)
)

mf_legend(
  type = "grad_line",
  val = c("", "\nCable car"),
  col = "brown4",
  lwd = linewidth,
  title = NA, 
  val_cex = 1.1,
  size = 1.1,
  pos = "bottomleft",
  adj = c(0,3)
)

mf_legend(
  type = "typo",
  val = "Urban area",
  pal = "grey80",
  title = NA, 
  val_cex = 1.1,
  size = 1.1,
  pos = "bottomleft",
  adj = c(0,0)
)

# Layout
mf_layout(
  credits = "",
  title = "",
  arrow = FALSE,
  scale = FALSE)


mf_credits(txt = "Source: Transmilenio S.A., 2023 - Package mapsf",
           col = "black",
           pos = "rightbottom",
           cex = 0.95,
           bg = "white"
)


mf_arrow(pos = "topleft", cex = 0.75)

mf_scale(size = 5, crs_units = "m", scale_units = "km", pos = "bottomright", adj = c(-20,0), cex = 1)
mf_frame(col = "black")

dev.off()
```

